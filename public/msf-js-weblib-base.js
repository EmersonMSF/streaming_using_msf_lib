/*! For license information please see msf-js-weblib-base.js.LICENSE.txt */
var streamingManager; (() => { var t = { 301: (t, e, r) => { var n; !function t(e, r, n) { function i(s, a) { if (!r[s]) { if (!e[s]) { var f = "function" == typeof call_me_man && call_me_man; if (!a && f) return f(s, !0); if (o) return o(s, !0); var u = new Error("Cannot find module '" + s + "'"); throw u.code = "MODULE_NOT_FOUND", u } var l = r[s] = { exports: {} }; e[s][0].call(l.exports, (function (t) { return i(e[s][1][t] || t) }), l, l.exports, t, e, r, n) } return r[s].exports } for (var o = "function" == typeof call_me_man && call_me_man, s = 0; s < n.length; s++)i(n[s]); return i }({ 1: [function (t, e, n) { (function (r) { "use strict"; var n = t("object-assign"); function i(t, e) { if (t === e) return 0; for (var r = t.length, n = e.length, i = 0, o = Math.min(r, n); i < o; ++i)if (t[i] !== e[i]) { r = t[i], n = e[i]; break } return r < n ? -1 : n < r ? 1 : 0 } function o(t) { return r.Buffer && "function" == typeof r.Buffer.isBuffer ? r.Buffer.isBuffer(t) : !(null == t || !t._isBuffer) } var s = t("util/"), a = Object.prototype.hasOwnProperty, f = Array.prototype.slice, u = "foo" === function () { }.name; function l(t) { return Object.prototype.toString.call(t) } function h(t) { return !o(t) && "function" == typeof r.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : !!t && (t instanceof DataView || !!(t.buffer && t.buffer instanceof ArrayBuffer))) } var c = e.exports = _, d = /\s*function\s+([^\(\s]*)\s*/; function p(t) { if (s.isFunction(t)) { if (u) return t.name; var e = t.toString().match(d); return e && e[1] } } function g(t, e) { return "string" == typeof t ? t.length < e ? t : t.slice(0, e) : t } function y(t) { if (u || !s.isFunction(t)) return s.inspect(t); var e = p(t); return "[Function" + (e ? ": " + e : "") + "]" } function b(t, e, r, n, i) { throw new c.AssertionError({ message: r, actual: t, expected: e, operator: n, stackStartFunction: i }) } function _(t, e) { t || b(t, !0, e, "==", c.ok) } function m(t, e, r, n) { if (t === e) return !0; if (o(t) && o(e)) return 0 === i(t, e); if (s.isDate(t) && s.isDate(e)) return t.getTime() === e.getTime(); if (s.isRegExp(t) && s.isRegExp(e)) return t.source === e.source && t.global === e.global && t.multiline === e.multiline && t.lastIndex === e.lastIndex && t.ignoreCase === e.ignoreCase; if (null !== t && "object" == typeof t || null !== e && "object" == typeof e) { if (h(t) && h(e) && l(t) === l(e) && !(t instanceof Float32Array || t instanceof Float64Array)) return 0 === i(new Uint8Array(t.buffer), new Uint8Array(e.buffer)); if (o(t) !== o(e)) return !1; var a = (n = n || { actual: [], expected: [] }).actual.indexOf(t); return -1 !== a && a === n.expected.indexOf(e) || (n.actual.push(t), n.expected.push(e), function (t, e, r, n) { if (null == t || null == e) return !1; if (s.isPrimitive(t) || s.isPrimitive(e)) return t === e; if (r && Object.getPrototypeOf(t) !== Object.getPrototypeOf(e)) return !1; var i = w(t), o = w(e); if (i && !o || !i && o) return !1; if (i) return m(t = f.call(t), e = f.call(e), r); var a, u, l = k(t), h = k(e); if (l.length !== h.length) return !1; for (l.sort(), h.sort(), u = l.length - 1; u >= 0; u--)if (l[u] !== h[u]) return !1; for (u = l.length - 1; u >= 0; u--)if (!m(t[a = l[u]], e[a], r, n)) return !1; return !0 }(t, e, r, n)) } return r ? t === e : t == e } function w(t) { return "[object Arguments]" == Object.prototype.toString.call(t) } function v(t, e) { if (!t || !e) return !1; if ("[object RegExp]" == Object.prototype.toString.call(e)) return e.test(t); try { if (t instanceof e) return !0 } catch (t) { } return !Error.isPrototypeOf(e) && !0 === e.call({}, t) } function E(t, e, r, n) { var i; if ("function" != typeof e) throw new TypeError('"block" argument must be a function'); "string" == typeof r && (n = r, r = null), i = function (t) { var e; try { t() } catch (t) { e = t } return e }(e), n = (r && r.name ? " (" + r.name + ")." : ".") + (n ? " " + n : "."), t && !i && b(i, r, "Missing expected exception" + n); var o = "string" == typeof n, a = !t && i && !r; if ((!t && s.isError(i) && o && v(i, r) || a) && b(i, r, "Got unwanted exception" + n), t && i && r && !v(i, r) || !t && i) throw i } c.AssertionError = function (t) { this.name = "AssertionError", this.actual = t.actual, this.expected = t.expected, this.operator = t.operator, t.message ? (this.message = t.message, this.generatedMessage = !1) : (this.message = function (t) { return g(y(t.actual), 128) + " " + t.operator + " " + g(y(t.expected), 128) }(this), this.generatedMessage = !0); var e = t.stackStartFunction || b; if (Error.captureStackTrace) Error.captureStackTrace(this, e); else { var r = new Error; if (r.stack) { var n = r.stack, i = p(e), o = n.indexOf("\n" + i); if (o >= 0) { var s = n.indexOf("\n", o + 1); n = n.substring(s + 1) } this.stack = n } } }, s.inherits(c.AssertionError, Error), c.fail = b, c.ok = _, c.equal = function (t, e, r) { t != e && b(t, e, r, "==", c.equal) }, c.notEqual = function (t, e, r) { t == e && b(t, e, r, "!=", c.notEqual) }, c.deepEqual = function (t, e, r) { m(t, e, !1) || b(t, e, r, "deepEqual", c.deepEqual) }, c.deepStrictEqual = function (t, e, r) { m(t, e, !0) || b(t, e, r, "deepStrictEqual", c.deepStrictEqual) }, c.notDeepEqual = function (t, e, r) { m(t, e, !1) && b(t, e, r, "notDeepEqual", c.notDeepEqual) }, c.notDeepStrictEqual = function t(e, r, n) { m(e, r, !0) && b(e, r, n, "notDeepStrictEqual", t) }, c.strictEqual = function (t, e, r) { t !== e && b(t, e, r, "===", c.strictEqual) }, c.notStrictEqual = function (t, e, r) { t === e && b(t, e, r, "!==", c.notStrictEqual) }, c.throws = function (t, e, r) { E(!0, t, e, r) }, c.doesNotThrow = function (t, e, r) { E(!1, t, e, r) }, c.ifError = function (t) { if (t) throw t }, c.strict = n((function t(e, r) { e || b(e, !0, r, "==", t) }), c, { equal: c.strictEqual, deepEqual: c.deepStrictEqual, notEqual: c.notStrictEqual, notDeepEqual: c.notDeepStrictEqual }), c.strict.strict = c.strict; var k = Object.keys || function (t) { var e = []; for (var r in t) a.call(t, r) && e.push(r); return e } }).call(this, void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "object-assign": 16, "util/": 4 }], 2: [function (t, e, r) { "function" == typeof Object.create ? e.exports = function (t, e) { t.super_ = e, t.prototype = Object.create(e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }) } : e.exports = function (t, e) { t.super_ = e; var r = function () { }; r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t } }, {}], 3: [function (t, e, r) { e.exports = function (t) { return t && "object" == typeof t && "function" == typeof t.copy && "function" == typeof t.fill && "function" == typeof t.readUInt8 } }, {}], 4: [function (t, e, n) { (function (e, r) { var i = /%[sdj%]/g; n.format = function (t) { if (!b(t)) { for (var e = [], r = 0; r < arguments.length; r++)e.push(a(arguments[r])); return e.join(" ") } r = 1; for (var n = arguments, o = n.length, s = String(t).replace(i, (function (t) { if ("%%" === t) return "%"; if (r >= o) return t; switch (t) { case "%s": return String(n[r++]); case "%d": return Number(n[r++]); case "%j": try { return JSON.stringify(n[r++]) } catch (t) { return "[Circular]" } default: return t } })), f = n[r]; r < o; f = n[++r])g(f) || !w(f) ? s += " " + f : s += " " + a(f); return s }, n.deprecate = function (t, i) { if (_(r.process)) return function () { return n.deprecate(t, i).apply(this, arguments) }; if (!0 === e.noDeprecation) return t; var o = !1; return function () { if (!o) { if (e.throwDeprecation) throw new Error(i); e.traceDeprecation ? console.trace(i) : console.error(i), o = !0 } return t.apply(this, arguments) } }; var o, s = {}; function a(t, e) { var r = { seen: [], stylize: u }; return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), p(e) ? r.showHidden = e : e && n._extend(r, e), _(r.showHidden) && (r.showHidden = !1), _(r.depth) && (r.depth = 2), _(r.colors) && (r.colors = !1), _(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = f), l(r, t, r.depth) } function f(t, e) { var r = a.styles[e]; return r ? "[" + a.colors[r][0] + "m" + t + "[" + a.colors[r][1] + "m" : t } function u(t, e) { return t } function l(t, e, r) { if (t.customInspect && e && k(e.inspect) && e.inspect !== n.inspect && (!e.constructor || e.constructor.prototype !== e)) { var i = e.inspect(r, t); return b(i) || (i = l(t, i, r)), i } var o = function (t, e) { if (_(e)) return t.stylize("undefined", "undefined"); if (b(e)) { var r = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return t.stylize(r, "string") } return y(e) ? t.stylize("" + e, "number") : p(e) ? t.stylize("" + e, "boolean") : g(e) ? t.stylize("null", "null") : void 0 }(t, e); if (o) return o; var s = Object.keys(e), a = function (t) { var e = {}; return t.forEach((function (t, r) { e[t] = !0 })), e }(s); if (t.showHidden && (s = Object.getOwnPropertyNames(e)), E(e) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0)) return h(e); if (0 === s.length) { if (k(e)) { var f = e.name ? ": " + e.name : ""; return t.stylize("[Function" + f + "]", "special") } if (m(e)) return t.stylize(RegExp.prototype.toString.call(e), "regexp"); if (v(e)) return t.stylize(Date.prototype.toString.call(e), "date"); if (E(e)) return h(e) } var u, w = "", S = !1, x = ["{", "}"]; return d(e) && (S = !0, x = ["[", "]"]), k(e) && (w = " [Function" + (e.name ? ": " + e.name : "") + "]"), m(e) && (w = " " + RegExp.prototype.toString.call(e)), v(e) && (w = " " + Date.prototype.toUTCString.call(e)), E(e) && (w = " " + h(e)), 0 !== s.length || S && 0 != e.length ? r < 0 ? m(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special") : (t.seen.push(e), u = S ? function (t, e, r, n, i) { for (var o = [], s = 0, a = e.length; s < a; ++s)B(e, String(s)) ? o.push(c(t, e, r, n, String(s), !0)) : o.push(""); return i.forEach((function (i) { i.match(/^\d+$/) || o.push(c(t, e, r, n, i, !0)) })), o }(t, e, r, a, s) : s.map((function (n) { return c(t, e, r, a, n, S) })), t.seen.pop(), function (t, e, r) { return t.reduce((function (t, e) { return e.indexOf("\n"), t + e.replace(/\u001b\[\d\d?m/g, "").length + 1 }), 0) > 60 ? r[0] + ("" === e ? "" : e + "\n ") + " " + t.join(",\n  ") + " " + r[1] : r[0] + e + " " + t.join(", ") + " " + r[1] }(u, w, x)) : x[0] + w + x[1] } function h(t) { return "[" + Error.prototype.toString.call(t) + "]" } function c(t, e, r, n, i, o) { var s, a, f; if ((f = Object.getOwnPropertyDescriptor(e, i) || { value: e[i] }).get ? a = f.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : f.set && (a = t.stylize("[Setter]", "special")), B(n, i) || (s = "[" + i + "]"), a || (t.seen.indexOf(f.value) < 0 ? (a = g(r) ? l(t, f.value, null) : l(t, f.value, r - 1)).indexOf("\n") > -1 && (a = o ? a.split("\n").map((function (t) { return "  " + t })).join("\n").substr(2) : "\n" + a.split("\n").map((function (t) { return "   " + t })).join("\n")) : a = t.stylize("[Circular]", "special")), _(s)) { if (o && i.match(/^\d+$/)) return a; (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = t.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = t.stylize(s, "string")) } return s + ": " + a } function d(t) { return Array.isArray(t) } function p(t) { return "boolean" == typeof t } function g(t) { return null === t } function y(t) { return "number" == typeof t } function b(t) { return "string" == typeof t } function _(t) { return void 0 === t } function m(t) { return w(t) && "[object RegExp]" === S(t) } function w(t) { return "object" == typeof t && null !== t } function v(t) { return w(t) && "[object Date]" === S(t) } function E(t) { return w(t) && ("[object Error]" === S(t) || t instanceof Error) } function k(t) { return "function" == typeof t } function S(t) { return Object.prototype.toString.call(t) } function x(t) { return t < 10 ? "0" + t.toString(10) : t.toString(10) } n.debuglog = function (t) { if (_(o) && (o = e.env.NODE_DEBUG || ""), t = t.toUpperCase(), !s[t]) if (new RegExp("\\b" + t + "\\b", "i").test(o)) { var r = e.pid; s[t] = function () { var e = n.format.apply(n, arguments); console.error("%s %d: %s", t, r, e) } } else s[t] = function () { }; return s[t] }, n.inspect = a, a.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, a.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, n.isArray = d, n.isBoolean = p, n.isNull = g, n.isNullOrUndefined = function (t) { return null == t }, n.isNumber = y, n.isString = b, n.isSymbol = function (t) { return "symbol" == typeof t }, n.isUndefined = _, n.isRegExp = m, n.isObject = w, n.isDate = v, n.isError = E, n.isFunction = k, n.isPrimitive = function (t) { return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t }, n.isBuffer = t("./support/isBuffer"); var L = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function A() { var t = new Date, e = [x(t.getHours()), x(t.getMinutes()), x(t.getSeconds())].join(":"); return [t.getDate(), L[t.getMonth()], e].join(" ") } function B(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } n.log = function () { console.log("%s - %s", A(), n.format.apply(n, arguments)) }, n.inherits = t("inherits"), n._extend = function (t, e) { if (!e || !w(e)) return t; for (var r = Object.keys(e), n = r.length; n--;)t[r[n]] = e[r[n]]; return t } }).call(this, t("_process"), void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "./support/isBuffer": 3, _process: 29, inherits: 2 }], 5: [function (t, e, r) { "use strict"; r.byteLength = function (t) { var e = u(t), r = e[0], n = e[1]; return 3 * (r + n) / 4 - n }, r.toByteArray = function (t) { var e, r, n = u(t), s = n[0], a = n[1], f = new o(function (t, e, r) { return 3 * (e + r) / 4 - r }(0, s, a)), l = 0, h = a > 0 ? s - 4 : s; for (r = 0; r < h; r += 4)e = i[t.charCodeAt(r)] << 18 | i[t.charCodeAt(r + 1)] << 12 | i[t.charCodeAt(r + 2)] << 6 | i[t.charCodeAt(r + 3)], f[l++] = e >> 16 & 255, f[l++] = e >> 8 & 255, f[l++] = 255 & e; return 2 === a && (e = i[t.charCodeAt(r)] << 2 | i[t.charCodeAt(r + 1)] >> 4, f[l++] = 255 & e), 1 === a && (e = i[t.charCodeAt(r)] << 10 | i[t.charCodeAt(r + 1)] << 4 | i[t.charCodeAt(r + 2)] >> 2, f[l++] = e >> 8 & 255, f[l++] = 255 & e), f }, r.fromByteArray = function (t) { for (var e, r = t.length, i = r % 3, o = [], s = 16383, a = 0, f = r - i; a < f; a += s)o.push(l(t, a, a + s > f ? f : a + s)); return 1 === i ? (e = t[r - 1], o.push(n[e >> 2] + n[e << 4 & 63] + "==")) : 2 === i && (e = (t[r - 2] << 8) + t[r - 1], o.push(n[e >> 10] + n[e >> 4 & 63] + n[e << 2 & 63] + "=")), o.join("") }; for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, f = s.length; a < f; ++a)n[a] = s[a], i[s.charCodeAt(a)] = a; function u(t) { var e = t.length; if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var r = t.indexOf("="); return -1 === r && (r = e), [r, r === e ? 0 : 4 - r % 4] } function l(t, e, r) { for (var i, o, s = [], a = e; a < r; a += 3)i = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]), s.push(n[(o = i) >> 18 & 63] + n[o >> 12 & 63] + n[o >> 6 & 63] + n[63 & o]); return s.join("") } i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63 }, {}], 6: [function (t, e, r) { }, {}], 7: [function (t, e, r) { (function (e, n) { "use strict"; var i = t("assert"), o = t("pako/lib/zlib/zstream"), s = t("pako/lib/zlib/deflate.js"), a = t("pako/lib/zlib/inflate.js"), f = t("pako/lib/zlib/constants"); for (var u in f) r[u] = f[u]; function l(t) { if ("number" != typeof t || t < r.DEFLATE || t > r.UNZIP) throw new TypeError("Bad argument"); this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = t, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0 } r.NONE = 0, r.DEFLATE = 1, r.INFLATE = 2, r.GZIP = 3, r.GUNZIP = 4, r.DEFLATERAW = 5, r.INFLATERAW = 6, r.UNZIP = 7, l.prototype.close = function () { this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, i(this.init_done, "close before init"), i(this.mode <= r.UNZIP), this.mode === r.DEFLATE || this.mode === r.GZIP || this.mode === r.DEFLATERAW ? s.deflateEnd(this.strm) : this.mode !== r.INFLATE && this.mode !== r.GUNZIP && this.mode !== r.INFLATERAW && this.mode !== r.UNZIP || a.inflateEnd(this.strm), this.mode = r.NONE, this.dictionary = null) }, l.prototype.write = function (t, e, r, n, i, o, s) { return this._write(!0, t, e, r, n, i, o, s) }, l.prototype.writeSync = function (t, e, r, n, i, o, s) { return this._write(!1, t, e, r, n, i, o, s) }, l.prototype._write = function (t, o, s, a, f, u, l, h) { if (i.equal(arguments.length, 8), i(this.init_done, "write before init"), i(this.mode !== r.NONE, "already finalized"), i.equal(!1, this.write_in_progress, "write already in progress"), i.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, i.equal(!1, void 0 === o, "must provide flush value"), this.write_in_progress = !0, o !== r.Z_NO_FLUSH && o !== r.Z_PARTIAL_FLUSH && o !== r.Z_SYNC_FLUSH && o !== r.Z_FULL_FLUSH && o !== r.Z_FINISH && o !== r.Z_BLOCK) throw new Error("Invalid flush value"); if (null == s && (s = n.alloc(0), f = 0, a = 0), this.strm.avail_in = f, this.strm.input = s, this.strm.next_in = a, this.strm.avail_out = h, this.strm.output = u, this.strm.next_out = l, this.flush = o, !t) return this._process(), this._checkError() ? this._afterSync() : void 0; var c = this; return e.nextTick((function () { c._process(), c._after() })), this }, l.prototype._afterSync = function () { var t = this.strm.avail_out, e = this.strm.avail_in; return this.write_in_progress = !1, [e, t] }, l.prototype._process = function () { var t = null; switch (this.mode) { case r.DEFLATE: case r.GZIP: case r.DEFLATERAW: this.err = s.deflate(this.strm, this.flush); break; case r.UNZIP: switch (this.strm.avail_in > 0 && (t = this.strm.next_in), this.gzip_id_bytes_read) { case 0: if (null === t) break; if (31 !== this.strm.input[t]) { this.mode = r.INFLATE; break } if (this.gzip_id_bytes_read = 1, t++, 1 === this.strm.avail_in) break; case 1: if (null === t) break; 139 === this.strm.input[t] ? (this.gzip_id_bytes_read = 2, this.mode = r.GUNZIP) : this.mode = r.INFLATE; break; default: throw new Error("invalid number of gzip magic number bytes read") }case r.INFLATE: case r.GUNZIP: case r.INFLATERAW: for (this.err = a.inflate(this.strm, this.flush), this.err === r.Z_NEED_DICT && this.dictionary && (this.err = a.inflateSetDictionary(this.strm, this.dictionary), this.err === r.Z_OK ? this.err = a.inflate(this.strm, this.flush) : this.err === r.Z_DATA_ERROR && (this.err = r.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === r.GUNZIP && this.err === r.Z_STREAM_END && 0 !== this.strm.next_in[0];)this.reset(), this.err = a.inflate(this.strm, this.flush); break; default: throw new Error("Unknown mode " + this.mode) } }, l.prototype._checkError = function () { switch (this.err) { case r.Z_OK: case r.Z_BUF_ERROR: if (0 !== this.strm.avail_out && this.flush === r.Z_FINISH) return this._error("unexpected end of file"), !1; break; case r.Z_STREAM_END: break; case r.Z_NEED_DICT: return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1; default: return this._error("Zlib error"), !1 }return !0 }, l.prototype._after = function () { if (this._checkError()) { var t = this.strm.avail_out, e = this.strm.avail_in; this.write_in_progress = !1, this.callback(e, t), this.pending_close && this.close() } }, l.prototype._error = function (t) { this.strm.msg && (t = this.strm.msg), this.onerror(t, this.err), this.write_in_progress = !1, this.pending_close && this.close() }, l.prototype.init = function (t, e, n, o, s) { i(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), i(t >= 8 && t <= 15, "invalid windowBits"), i(e >= -1 && e <= 9, "invalid compression level"), i(n >= 1 && n <= 9, "invalid memlevel"), i(o === r.Z_FILTERED || o === r.Z_HUFFMAN_ONLY || o === r.Z_RLE || o === r.Z_FIXED || o === r.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(e, t, n, o, s), this._setDictionary() }, l.prototype.params = function () { throw new Error("deflateParams Not supported") }, l.prototype.reset = function () { this._reset(), this._setDictionary() }, l.prototype._init = function (t, e, n, i, f) { switch (this.level = t, this.windowBits = e, this.memLevel = n, this.strategy = i, this.flush = r.Z_NO_FLUSH, this.err = r.Z_OK, this.mode !== r.GZIP && this.mode !== r.GUNZIP || (this.windowBits += 16), this.mode === r.UNZIP && (this.windowBits += 32), this.mode !== r.DEFLATERAW && this.mode !== r.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new o, this.mode) { case r.DEFLATE: case r.GZIP: case r.DEFLATERAW: this.err = s.deflateInit2(this.strm, this.level, r.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy); break; case r.INFLATE: case r.GUNZIP: case r.INFLATERAW: case r.UNZIP: this.err = a.inflateInit2(this.strm, this.windowBits); break; default: throw new Error("Unknown mode " + this.mode) }this.err !== r.Z_OK && this._error("Init error"), this.dictionary = f, this.write_in_progress = !1, this.init_done = !0 }, l.prototype._setDictionary = function () { if (null != this.dictionary) { switch (this.err = r.Z_OK, this.mode) { case r.DEFLATE: case r.DEFLATERAW: this.err = s.deflateSetDictionary(this.strm, this.dictionary) }this.err !== r.Z_OK && this._error("Failed to set dictionary") } }, l.prototype._reset = function () { switch (this.err = r.Z_OK, this.mode) { case r.DEFLATE: case r.DEFLATERAW: case r.GZIP: this.err = s.deflateReset(this.strm); break; case r.INFLATE: case r.INFLATERAW: case r.GUNZIP: this.err = a.inflateReset(this.strm) }this.err !== r.Z_OK && this._error("Failed to reset stream") }, r.Zlib = l }).call(this, t("_process"), t("buffer").Buffer) }, { _process: 29, assert: 1, buffer: 9, "pako/lib/zlib/constants": 19, "pako/lib/zlib/deflate.js": 21, "pako/lib/zlib/inflate.js": 23, "pako/lib/zlib/zstream": 27 }], 8: [function (t, e, r) { (function (e) { "use strict"; var n = t("buffer").Buffer, i = t("stream").Transform, o = t("./binding"), s = t("util"), a = t("assert").ok, f = t("buffer").kMaxLength, u = "Cannot create final Buffer. It would be larger than 0x" + f.toString(16) + " bytes"; o.Z_MIN_WINDOWBITS = 8, o.Z_MAX_WINDOWBITS = 15, o.Z_DEFAULT_WINDOWBITS = 15, o.Z_MIN_CHUNK = 64, o.Z_MAX_CHUNK = 1 / 0, o.Z_DEFAULT_CHUNK = 16384, o.Z_MIN_MEMLEVEL = 1, o.Z_MAX_MEMLEVEL = 9, o.Z_DEFAULT_MEMLEVEL = 8, o.Z_MIN_LEVEL = -1, o.Z_MAX_LEVEL = 9, o.Z_DEFAULT_LEVEL = o.Z_DEFAULT_COMPRESSION; for (var l = Object.keys(o), h = 0; h < l.length; h++) { var c = l[h]; c.match(/^Z/) && Object.defineProperty(r, c, { enumerable: !0, value: o[c], writable: !1 }) } for (var d = { Z_OK: o.Z_OK, Z_STREAM_END: o.Z_STREAM_END, Z_NEED_DICT: o.Z_NEED_DICT, Z_ERRNO: o.Z_ERRNO, Z_STREAM_ERROR: o.Z_STREAM_ERROR, Z_DATA_ERROR: o.Z_DATA_ERROR, Z_MEM_ERROR: o.Z_MEM_ERROR, Z_BUF_ERROR: o.Z_BUF_ERROR, Z_VERSION_ERROR: o.Z_VERSION_ERROR }, p = Object.keys(d), g = 0; g < p.length; g++) { var y = p[g]; d[d[y]] = y } function b(t, e, r) { var i = [], o = 0; function s() { for (var e; null !== (e = t.read());)i.push(e), o += e.length; t.once("readable", s) } function a() { var e, s = null; o >= f ? s = new RangeError(u) : e = n.concat(i, o), i = [], t.close(), r(s, e) } t.on("error", (function (e) { t.removeListener("end", a), t.removeListener("readable", s), r(e) })), t.on("end", a), t.end(e), s() } function _(t, e) { if ("string" == typeof e && (e = n.from(e)), !n.isBuffer(e)) throw new TypeError("Not a string or buffer"); var r = t._finishFlushFlag; return t._processChunk(e, r) } function m(t) { if (!(this instanceof m)) return new m(t); A.call(this, t, o.DEFLATE) } function w(t) { if (!(this instanceof w)) return new w(t); A.call(this, t, o.INFLATE) } function v(t) { if (!(this instanceof v)) return new v(t); A.call(this, t, o.GZIP) } function E(t) { if (!(this instanceof E)) return new E(t); A.call(this, t, o.GUNZIP) } function k(t) { if (!(this instanceof k)) return new k(t); A.call(this, t, o.DEFLATERAW) } function S(t) { if (!(this instanceof S)) return new S(t); A.call(this, t, o.INFLATERAW) } function x(t) { if (!(this instanceof x)) return new x(t); A.call(this, t, o.UNZIP) } function L(t) { return t === o.Z_NO_FLUSH || t === o.Z_PARTIAL_FLUSH || t === o.Z_SYNC_FLUSH || t === o.Z_FULL_FLUSH || t === o.Z_FINISH || t === o.Z_BLOCK } function A(t, e) { var s = this; if (this._opts = t = t || {}, this._chunkSize = t.chunkSize || r.Z_DEFAULT_CHUNK, i.call(this, t), t.flush && !L(t.flush)) throw new Error("Invalid flush flag: " + t.flush); if (t.finishFlush && !L(t.finishFlush)) throw new Error("Invalid flush flag: " + t.finishFlush); if (this._flushFlag = t.flush || o.Z_NO_FLUSH, this._finishFlushFlag = void 0 !== t.finishFlush ? t.finishFlush : o.Z_FINISH, t.chunkSize && (t.chunkSize < r.Z_MIN_CHUNK || t.chunkSize > r.Z_MAX_CHUNK)) throw new Error("Invalid chunk size: " + t.chunkSize); if (t.windowBits && (t.windowBits < r.Z_MIN_WINDOWBITS || t.windowBits > r.Z_MAX_WINDOWBITS)) throw new Error("Invalid windowBits: " + t.windowBits); if (t.level && (t.level < r.Z_MIN_LEVEL || t.level > r.Z_MAX_LEVEL)) throw new Error("Invalid compression level: " + t.level); if (t.memLevel && (t.memLevel < r.Z_MIN_MEMLEVEL || t.memLevel > r.Z_MAX_MEMLEVEL)) throw new Error("Invalid memLevel: " + t.memLevel); if (t.strategy && t.strategy != r.Z_FILTERED && t.strategy != r.Z_HUFFMAN_ONLY && t.strategy != r.Z_RLE && t.strategy != r.Z_FIXED && t.strategy != r.Z_DEFAULT_STRATEGY) throw new Error("Invalid strategy: " + t.strategy); if (t.dictionary && !n.isBuffer(t.dictionary)) throw new Error("Invalid dictionary: it should be a Buffer instance"); this._handle = new o.Zlib(e); var a = this; this._hadError = !1, this._handle.onerror = function (t, e) { B(a), a._hadError = !0; var n = new Error(t); n.errno = e, n.code = r.codes[e], a.emit("error", n) }; var f = r.Z_DEFAULT_COMPRESSION; "number" == typeof t.level && (f = t.level); var u = r.Z_DEFAULT_STRATEGY; "number" == typeof t.strategy && (u = t.strategy), this._handle.init(t.windowBits || r.Z_DEFAULT_WINDOWBITS, f, t.memLevel || r.Z_DEFAULT_MEMLEVEL, u, t.dictionary), this._buffer = n.allocUnsafe(this._chunkSize), this._offset = 0, this._level = f, this._strategy = u, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function () { return !s._handle }, configurable: !0, enumerable: !0 }) } function B(t, r) { r && e.nextTick(r), t._handle && (t._handle.close(), t._handle = null) } function T(t) { t.emit("close") } Object.defineProperty(r, "codes", { enumerable: !0, value: Object.freeze(d), writable: !1 }), r.Deflate = m, r.Inflate = w, r.Gzip = v, r.Gunzip = E, r.DeflateRaw = k, r.InflateRaw = S, r.Unzip = x, r.createDeflate = function (t) { return new m(t) }, r.createInflate = function (t) { return new w(t) }, r.createDeflateRaw = function (t) { return new k(t) }, r.createInflateRaw = function (t) { return new S(t) }, r.createGzip = function (t) { return new v(t) }, r.createGunzip = function (t) { return new E(t) }, r.createUnzip = function (t) { return new x(t) }, r.deflate = function (t, e, r) { return "function" == typeof e && (r = e, e = {}), b(new m(e), t, r) }, r.deflateSync = function (t, e) { return _(new m(e), t) }, r.gzip = function (t, e, r) { return "function" == typeof e && (r = e, e = {}), b(new v(e), t, r) }, r.gzipSync = function (t, e) { return _(new v(e), t) }, r.deflateRaw = function (t, e, r) { return "function" == typeof e && (r = e, e = {}), b(new k(e), t, r) }, r.deflateRawSync = function (t, e) { return _(new k(e), t) }, r.unzip = function (t, e, r) { return "function" == typeof e && (r = e, e = {}), b(new x(e), t, r) }, r.unzipSync = function (t, e) { return _(new x(e), t) }, r.inflate = function (t, e, r) { return "function" == typeof e && (r = e, e = {}), b(new w(e), t, r) }, r.inflateSync = function (t, e) { return _(new w(e), t) }, r.gunzip = function (t, e, r) { return "function" == typeof e && (r = e, e = {}), b(new E(e), t, r) }, r.gunzipSync = function (t, e) { return _(new E(e), t) }, r.inflateRaw = function (t, e, r) { return "function" == typeof e && (r = e, e = {}), b(new S(e), t, r) }, r.inflateRawSync = function (t, e) { return _(new S(e), t) }, s.inherits(A, i), A.prototype.params = function (t, n, i) { if (t < r.Z_MIN_LEVEL || t > r.Z_MAX_LEVEL) throw new RangeError("Invalid compression level: " + t); if (n != r.Z_FILTERED && n != r.Z_HUFFMAN_ONLY && n != r.Z_RLE && n != r.Z_FIXED && n != r.Z_DEFAULT_STRATEGY) throw new TypeError("Invalid strategy: " + n); if (this._level !== t || this._strategy !== n) { var s = this; this.flush(o.Z_SYNC_FLUSH, (function () { a(s._handle, "zlib binding closed"), s._handle.params(t, n), s._hadError || (s._level = t, s._strategy = n, i && i()) })) } else e.nextTick(i) }, A.prototype.reset = function () { return a(this._handle, "zlib binding closed"), this._handle.reset() }, A.prototype._flush = function (t) { this._transform(n.alloc(0), "", t) }, A.prototype.flush = function (t, r) { var i = this, s = this._writableState; ("function" == typeof t || void 0 === t && !r) && (r = t, t = o.Z_FULL_FLUSH), s.ended ? r && e.nextTick(r) : s.ending ? r && this.once("end", r) : s.needDrain ? r && this.once("drain", (function () { return i.flush(t, r) })) : (this._flushFlag = t, this.write(n.alloc(0), "", r)) }, A.prototype.close = function (t) { B(this, t), e.nextTick(T, this) }, A.prototype._transform = function (t, e, r) { var i, s = this._writableState, a = (s.ending || s.ended) && (!t || s.length === t.length); return null === t || n.isBuffer(t) ? this._handle ? (a ? i = this._finishFlushFlag : (i = this._flushFlag, t.length >= s.length && (this._flushFlag = this._opts.flush || o.Z_NO_FLUSH)), void this._processChunk(t, i, r)) : r(new Error("zlib binding closed")) : r(new Error("invalid input")) }, A.prototype._processChunk = function (t, e, r) { var i = t && t.length, o = this._chunkSize - this._offset, s = 0, l = this, h = "function" == typeof r; if (!h) { var c, d = [], p = 0; this.on("error", (function (t) { c = t })), a(this._handle, "zlib binding closed"); do { var g = this._handle.writeSync(e, t, s, i, this._buffer, this._offset, o) } while (!this._hadError && _(g[0], g[1])); if (this._hadError) throw c; if (p >= f) throw B(this), new RangeError(u); var y = n.concat(d, p); return B(this), y } a(this._handle, "zlib binding closed"); var b = this._handle.write(e, t, s, i, this._buffer, this._offset, o); function _(f, u) { if (this && (this.buffer = null, this.callback = null), !l._hadError) { var c = o - u; if (a(c >= 0, "have should not go down"), c > 0) { var g = l._buffer.slice(l._offset, l._offset + c); l._offset += c, h ? l.push(g) : (d.push(g), p += g.length) } if ((0 === u || l._offset >= l._chunkSize) && (o = l._chunkSize, l._offset = 0, l._buffer = n.allocUnsafe(l._chunkSize)), 0 === u) { if (s += i - f, i = f, !h) return !0; var y = l._handle.write(e, t, s, i, l._buffer, l._offset, l._chunkSize); return y.callback = _, void (y.buffer = t) } if (!h) return !1; r() } } b.buffer = t, b.callback = _ }, s.inherits(m, A), s.inherits(w, A), s.inherits(v, A), s.inherits(E, A), s.inherits(k, A), s.inherits(S, A), s.inherits(x, A) }).call(this, t("_process")) }, { "./binding": 7, _process: 29, assert: 1, buffer: 9, stream: 45, util: 50 }], 9: [function (t, e, r) { (function (e) { "use strict"; var n = t("base64-js"), i = t("ieee754"); r.Buffer = e, r.SlowBuffer = function (t) { return +t != t && (t = 0), e.alloc(+t) }, r.INSPECT_MAX_BYTES = 50; var o = 2147483647; function s(t) { if (t > o) throw new RangeError('The value "' + t + '" is invalid for option "size"'); var r = new Uint8Array(t); return r.__proto__ = e.prototype, r } function e(t, e, r) { if ("number" == typeof t) { if ("string" == typeof e) throw new TypeError('The "string" argument must be of type string. Received type number'); return u(t) } return a(t, e, r) } function a(t, r, n) { if ("string" == typeof t) return function (t, r) { if ("string" == typeof r && "" !== r || (r = "utf8"), !e.isEncoding(r)) throw new TypeError("Unknown encoding: " + r); var n = 0 | c(t, r), i = s(n), o = i.write(t, r); return o !== n && (i = i.slice(0, o)), i }(t, r); if (ArrayBuffer.isView(t)) return l(t); if (null == t) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); if (D(t, ArrayBuffer) || t && D(t.buffer, ArrayBuffer)) return function (t, r, n) { if (r < 0 || t.byteLength < r) throw new RangeError('"offset" is outside of buffer bounds'); if (t.byteLength < r + (n || 0)) throw new RangeError('"length" is outside of buffer bounds'); var i; return (i = void 0 === r && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, r) : new Uint8Array(t, r, n)).__proto__ = e.prototype, i }(t, r, n); if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number'); var i = t.valueOf && t.valueOf(); if (null != i && i !== t) return e.from(i, r, n); var o = function (t) { if (e.isBuffer(t)) { var r = 0 | h(t.length), n = s(r); return 0 === n.length || t.copy(n, 0, 0, r), n } return void 0 !== t.length ? "number" != typeof t.length || F(t.length) ? s(0) : l(t) : "Buffer" === t.type && Array.isArray(t.data) ? l(t.data) : void 0 }(t); if (o) return o; if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return e.from(t[Symbol.toPrimitive]("string"), r, n); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t) } function f(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be of type number'); if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"') } function u(t) { return f(t), s(t < 0 ? 0 : 0 | h(t)) } function l(t) { for (var e = t.length < 0 ? 0 : 0 | h(t.length), r = s(e), n = 0; n < e; n += 1)r[n] = 255 & t[n]; return r } function h(t) { if (t >= o) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes"); return 0 | t } function c(t, r) { if (e.isBuffer(t)) return t.length; if (ArrayBuffer.isView(t) || D(t, ArrayBuffer)) return t.byteLength; if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t); var n = t.length, i = arguments.length > 2 && !0 === arguments[2]; if (!i && 0 === n) return 0; for (var o = !1; ;)switch (r) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": return M(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return z(t).length; default: if (o) return i ? -1 : M(t).length; r = ("" + r).toLowerCase(), o = !0 } } function d(t, e, r) { var n = !1; if ((void 0 === e || e < 0) && (e = 0), e > this.length) return ""; if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return ""; if ((r >>>= 0) <= (e >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return B(this, e, r); case "utf8": case "utf-8": return S(this, e, r); case "ascii": return L(this, e, r); case "latin1": case "binary": return A(this, e, r); case "base64": return k(this, e, r); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return T(this, e, r); default: if (n) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), n = !0 } } function p(t, e, r) { var n = t[e]; t[e] = t[r], t[r] = n } function g(t, r, n, i, o) { if (0 === t.length) return -1; if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), F(n = +n) && (n = o ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) { if (o) return -1; n = t.length - 1 } else if (n < 0) { if (!o) return -1; n = 0 } if ("string" == typeof r && (r = e.from(r, i)), e.isBuffer(r)) return 0 === r.length ? -1 : y(t, r, n, i, o); if ("number" == typeof r) return r &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, r, n) : Uint8Array.prototype.lastIndexOf.call(t, r, n) : y(t, [r], n, i, o); throw new TypeError("val must be string, number or Buffer") } function y(t, e, r, n, i) { var o, s = 1, a = t.length, f = e.length; if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) { if (t.length < 2 || e.length < 2) return -1; s = 2, a /= 2, f /= 2, r /= 2 } function u(t, e) { return 1 === s ? t[e] : t.readUInt16BE(e * s) } if (i) { var l = -1; for (o = r; o < a; o++)if (u(t, o) === u(e, -1 === l ? 0 : o - l)) { if (-1 === l && (l = o), o - l + 1 === f) return l * s } else -1 !== l && (o -= o - l), l = -1 } else for (r + f > a && (r = a - f), o = r; o >= 0; o--) { for (var h = !0, c = 0; c < f; c++)if (u(t, o + c) !== u(e, c)) { h = !1; break } if (h) return o } return -1 } function b(t, e, r, n) { r = Number(r) || 0; var i = t.length - r; n ? (n = Number(n)) > i && (n = i) : n = i; var o = e.length; n > o / 2 && (n = o / 2); for (var s = 0; s < n; ++s) { var a = parseInt(e.substr(2 * s, 2), 16); if (F(a)) return s; t[r + s] = a } return s } function _(t, e, r, n) { return j(M(e, t.length - r), t, r, n) } function m(t, e, r, n) { return j(function (t) { for (var e = [], r = 0; r < t.length; ++r)e.push(255 & t.charCodeAt(r)); return e }(e), t, r, n) } function w(t, e, r, n) { return m(t, e, r, n) } function v(t, e, r, n) { return j(z(e), t, r, n) } function E(t, e, r, n) { return j(function (t, e) { for (var r, n, i, o = [], s = 0; s < t.length && !((e -= 2) < 0); ++s)n = (r = t.charCodeAt(s)) >> 8, i = r % 256, o.push(i), o.push(n); return o }(e, t.length - r), t, r, n) } function k(t, e, r) { return 0 === e && r === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(e, r)) } function S(t, e, r) { r = Math.min(t.length, r); for (var n = [], i = e; i < r;) { var o, s, a, f, u = t[i], l = null, h = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1; if (i + h <= r) switch (h) { case 1: u < 128 && (l = u); break; case 2: 128 == (192 & (o = t[i + 1])) && (f = (31 & u) << 6 | 63 & o) > 127 && (l = f); break; case 3: o = t[i + 1], s = t[i + 2], 128 == (192 & o) && 128 == (192 & s) && (f = (15 & u) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (f < 55296 || f > 57343) && (l = f); break; case 4: o = t[i + 1], s = t[i + 2], a = t[i + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (f = (15 & u) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && f < 1114112 && (l = f) }null === l ? (l = 65533, h = 1) : l > 65535 && (l -= 65536, n.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n.push(l), i += h } return function (t) { var e = t.length; if (e <= x) return String.fromCharCode.apply(String, t); for (var r = "", n = 0; n < e;)r += String.fromCharCode.apply(String, t.slice(n, n += x)); return r }(n) } r.kMaxLength = o, e.TYPED_ARRAY_SUPPORT = function () { try { var t = new Uint8Array(1); return t.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === t.foo() } catch (t) { return !1 } }(), e.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is call_me_mand by `buffer` v5.x. Use `buffer` v4.x if you call_me_man old browser support."), Object.defineProperty(e.prototype, "parent", { enumerable: !0, get: function () { if (e.isBuffer(this)) return this.buffer } }), Object.defineProperty(e.prototype, "offset", { enumerable: !0, get: function () { if (e.isBuffer(this)) return this.byteOffset } }), "undefined" != typeof Symbol && null != Symbol.species && e[Symbol.species] === e && Object.defineProperty(e, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), e.poolSize = 8192, e.from = function (t, e, r) { return a(t, e, r) }, e.prototype.__proto__ = Uint8Array.prototype, e.__proto__ = Uint8Array, e.alloc = function (t, e, r) { return function (t, e, r) { return f(t), t <= 0 ? s(t) : void 0 !== e ? "string" == typeof r ? s(t).fill(e, r) : s(t).fill(e) : s(t) }(t, e, r) }, e.allocUnsafe = function (t) { return u(t) }, e.allocUnsafeSlow = function (t) { return u(t) }, e.isBuffer = function (t) { return null != t && !0 === t._isBuffer && t !== e.prototype }, e.compare = function (t, r) { if (D(t, Uint8Array) && (t = e.from(t, t.offset, t.byteLength)), D(r, Uint8Array) && (r = e.from(r, r.offset, r.byteLength)), !e.isBuffer(t) || !e.isBuffer(r)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (t === r) return 0; for (var n = t.length, i = r.length, o = 0, s = Math.min(n, i); o < s; ++o)if (t[o] !== r[o]) { n = t[o], i = r[o]; break } return n < i ? -1 : i < n ? 1 : 0 }, e.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, e.concat = function (t, r) { if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return e.alloc(0); var n; if (void 0 === r) for (r = 0, n = 0; n < t.length; ++n)r += t[n].length; var i = e.allocUnsafe(r), o = 0; for (n = 0; n < t.length; ++n) { var s = t[n]; if (D(s, Uint8Array) && (s = e.from(s)), !e.isBuffer(s)) throw new TypeError('"list" argument must be an Array of Buffers'); s.copy(i, o), o += s.length } return i }, e.byteLength = c, e.prototype._isBuffer = !0, e.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var e = 0; e < t; e += 2)p(this, e, e + 1); return this }, e.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var e = 0; e < t; e += 4)p(this, e, e + 3), p(this, e + 1, e + 2); return this }, e.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var e = 0; e < t; e += 8)p(this, e, e + 7), p(this, e + 1, e + 6), p(this, e + 2, e + 5), p(this, e + 3, e + 4); return this }, e.prototype.toString = function () { var t = this.length; return 0 === t ? "" : 0 === arguments.length ? S(this, 0, t) : d.apply(this, arguments) }, e.prototype.toLocaleString = e.prototype.toString, e.prototype.equals = function (t) { if (!e.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === e.compare(this, t) }, e.prototype.inspect = function () { var t = "", e = r.INSPECT_MAX_BYTES; return t = this.toString("hex", 0, e).replace(/(.{2})/g, "$1 ").trim(), this.length > e && (t += " ... "), "<Buffer " + t + ">" }, e.prototype.compare = function (t, r, n, i, o) { if (D(t, Uint8Array) && (t = e.from(t, t.offset, t.byteLength)), !e.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t); if (void 0 === r && (r = 0), void 0 === n && (n = t ? t.length : 0), void 0 === i && (i = 0), void 0 === o && (o = this.length), r < 0 || n > t.length || i < 0 || o > this.length) throw new RangeError("out of range index"); if (i >= o && r >= n) return 0; if (i >= o) return -1; if (r >= n) return 1; if (this === t) return 0; for (var s = (o >>>= 0) - (i >>>= 0), a = (n >>>= 0) - (r >>>= 0), f = Math.min(s, a), u = this.slice(i, o), l = t.slice(r, n), h = 0; h < f; ++h)if (u[h] !== l[h]) { s = u[h], a = l[h]; break } return s < a ? -1 : a < s ? 1 : 0 }, e.prototype.includes = function (t, e, r) { return -1 !== this.indexOf(t, e, r) }, e.prototype.indexOf = function (t, e, r) { return g(this, t, e, r, !0) }, e.prototype.lastIndexOf = function (t, e, r) { return g(this, t, e, r, !1) }, e.prototype.write = function (t, e, r, n) { if (void 0 === e) n = "utf8", r = this.length, e = 0; else if (void 0 === r && "string" == typeof e) n = e, r = this.length, e = 0; else { if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); e >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0) } var i = this.length - e; if ((void 0 === r || r > i) && (r = i), t.length > 0 && (r < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); for (var o = !1; ;)switch (n) { case "hex": return b(this, t, e, r); case "utf8": case "utf-8": return _(this, t, e, r); case "ascii": return m(this, t, e, r); case "latin1": case "binary": return w(this, t, e, r); case "base64": return v(this, t, e, r); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return E(this, t, e, r); default: if (o) throw new TypeError("Unknown encoding: " + n); n = ("" + n).toLowerCase(), o = !0 } }, e.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var x = 4096; function L(t, e, r) { var n = ""; r = Math.min(t.length, r); for (var i = e; i < r; ++i)n += String.fromCharCode(127 & t[i]); return n } function A(t, e, r) { var n = ""; r = Math.min(t.length, r); for (var i = e; i < r; ++i)n += String.fromCharCode(t[i]); return n } function B(t, e, r) { var n, i = t.length; (!e || e < 0) && (e = 0), (!r || r < 0 || r > i) && (r = i); for (var o = "", s = e; s < r; ++s)o += (n = t[s]) < 16 ? "0" + n.toString(16) : n.toString(16); return o } function T(t, e, r) { for (var n = t.slice(e, r), i = "", o = 0; o < n.length; o += 2)i += String.fromCharCode(n[o] + 256 * n[o + 1]); return i } function I(t, e, r) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + e > r) throw new RangeError("Trying to access beyond buffer length") } function R(t, r, n, i, o, s) { if (!e.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (r > o || r < s) throw new RangeError('"value" argument is out of bounds'); if (n + i > t.length) throw new RangeError("Index out of range") } function O(t, e, r, n, i, o) { if (r + n > t.length) throw new RangeError("Index out of range"); if (r < 0) throw new RangeError("Index out of range") } function U(t, e, r, n, o) { return e = +e, r >>>= 0, o || O(t, 0, r, 4), i.write(t, e, r, n, 23, 4), r + 4 } function N(t, e, r, n, o) { return e = +e, r >>>= 0, o || O(t, 0, r, 8), i.write(t, e, r, n, 52, 8), r + 8 } e.prototype.slice = function (t, r) { var n = this.length; (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (r = void 0 === r ? n : ~~r) < 0 ? (r += n) < 0 && (r = 0) : r > n && (r = n), r < t && (r = t); var i = this.subarray(t, r); return i.__proto__ = e.prototype, i }, e.prototype.readUIntLE = function (t, e, r) { t >>>= 0, e >>>= 0, r || I(t, e, this.length); for (var n = this[t], i = 1, o = 0; ++o < e && (i *= 256);)n += this[t + o] * i; return n }, e.prototype.readUIntBE = function (t, e, r) { t >>>= 0, e >>>= 0, r || I(t, e, this.length); for (var n = this[t + --e], i = 1; e > 0 && (i *= 256);)n += this[t + --e] * i; return n }, e.prototype.readUInt8 = function (t, e) { return t >>>= 0, e || I(t, 1, this.length), this[t] }, e.prototype.readUInt16LE = function (t, e) { return t >>>= 0, e || I(t, 2, this.length), this[t] | this[t + 1] << 8 }, e.prototype.readUInt16BE = function (t, e) { return t >>>= 0, e || I(t, 2, this.length), this[t] << 8 | this[t + 1] }, e.prototype.readUInt32LE = function (t, e) { return t >>>= 0, e || I(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, e.prototype.readUInt32BE = function (t, e) { return t >>>= 0, e || I(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, e.prototype.readIntLE = function (t, e, r) { t >>>= 0, e >>>= 0, r || I(t, e, this.length); for (var n = this[t], i = 1, o = 0; ++o < e && (i *= 256);)n += this[t + o] * i; return n >= (i *= 128) && (n -= Math.pow(2, 8 * e)), n }, e.prototype.readIntBE = function (t, e, r) { t >>>= 0, e >>>= 0, r || I(t, e, this.length); for (var n = e, i = 1, o = this[t + --n]; n > 0 && (i *= 256);)o += this[t + --n] * i; return o >= (i *= 128) && (o -= Math.pow(2, 8 * e)), o }, e.prototype.readInt8 = function (t, e) { return t >>>= 0, e || I(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, e.prototype.readInt16LE = function (t, e) { t >>>= 0, e || I(t, 2, this.length); var r = this[t] | this[t + 1] << 8; return 32768 & r ? 4294901760 | r : r }, e.prototype.readInt16BE = function (t, e) { t >>>= 0, e || I(t, 2, this.length); var r = this[t + 1] | this[t] << 8; return 32768 & r ? 4294901760 | r : r }, e.prototype.readInt32LE = function (t, e) { return t >>>= 0, e || I(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, e.prototype.readInt32BE = function (t, e) { return t >>>= 0, e || I(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, e.prototype.readFloatLE = function (t, e) { return t >>>= 0, e || I(t, 4, this.length), i.read(this, t, !0, 23, 4) }, e.prototype.readFloatBE = function (t, e) { return t >>>= 0, e || I(t, 4, this.length), i.read(this, t, !1, 23, 4) }, e.prototype.readDoubleLE = function (t, e) { return t >>>= 0, e || I(t, 8, this.length), i.read(this, t, !0, 52, 8) }, e.prototype.readDoubleBE = function (t, e) { return t >>>= 0, e || I(t, 8, this.length), i.read(this, t, !1, 52, 8) }, e.prototype.writeUIntLE = function (t, e, r, n) { t = +t, e >>>= 0, r >>>= 0, n || R(this, t, e, r, Math.pow(2, 8 * r) - 1, 0); var i = 1, o = 0; for (this[e] = 255 & t; ++o < r && (i *= 256);)this[e + o] = t / i & 255; return e + r }, e.prototype.writeUIntBE = function (t, e, r, n) { t = +t, e >>>= 0, r >>>= 0, n || R(this, t, e, r, Math.pow(2, 8 * r) - 1, 0); var i = r - 1, o = 1; for (this[e + i] = 255 & t; --i >= 0 && (o *= 256);)this[e + i] = t / o & 255; return e + r }, e.prototype.writeUInt8 = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 1, 255, 0), this[e] = 255 & t, e + 1 }, e.prototype.writeUInt16LE = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 2, 65535, 0), this[e] = 255 & t, this[e + 1] = t >>> 8, e + 2 }, e.prototype.writeUInt16BE = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 2, 65535, 0), this[e] = t >>> 8, this[e + 1] = 255 & t, e + 2 }, e.prototype.writeUInt32LE = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 4, 4294967295, 0), this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t, e + 4 }, e.prototype.writeUInt32BE = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 4, 4294967295, 0), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4 }, e.prototype.writeIntLE = function (t, e, r, n) { if (t = +t, e >>>= 0, !n) { var i = Math.pow(2, 8 * r - 1); R(this, t, e, r, i - 1, -i) } var o = 0, s = 1, a = 0; for (this[e] = 255 & t; ++o < r && (s *= 256);)t < 0 && 0 === a && 0 !== this[e + o - 1] && (a = 1), this[e + o] = (t / s >> 0) - a & 255; return e + r }, e.prototype.writeIntBE = function (t, e, r, n) { if (t = +t, e >>>= 0, !n) { var i = Math.pow(2, 8 * r - 1); R(this, t, e, r, i - 1, -i) } var o = r - 1, s = 1, a = 0; for (this[e + o] = 255 & t; --o >= 0 && (s *= 256);)t < 0 && 0 === a && 0 !== this[e + o + 1] && (a = 1), this[e + o] = (t / s >> 0) - a & 255; return e + r }, e.prototype.writeInt8 = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1 }, e.prototype.writeInt16LE = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 2, 32767, -32768), this[e] = 255 & t, this[e + 1] = t >>> 8, e + 2 }, e.prototype.writeInt16BE = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 2, 32767, -32768), this[e] = t >>> 8, this[e + 1] = 255 & t, e + 2 }, e.prototype.writeInt32LE = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 4, 2147483647, -2147483648), this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24, e + 4 }, e.prototype.writeInt32BE = function (t, e, r) { return t = +t, e >>>= 0, r || R(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4 }, e.prototype.writeFloatLE = function (t, e, r) { return U(this, t, e, !0, r) }, e.prototype.writeFloatBE = function (t, e, r) { return U(this, t, e, !1, r) }, e.prototype.writeDoubleLE = function (t, e, r) { return N(this, t, e, !0, r) }, e.prototype.writeDoubleBE = function (t, e, r) { return N(this, t, e, !1, r) }, e.prototype.copy = function (t, r, n, i) { if (!e.isBuffer(t)) throw new TypeError("argument should be a Buffer"); if (n || (n = 0), i || 0 === i || (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n) return 0; if (0 === t.length || 0 === this.length) return 0; if (r < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("Index out of range"); if (i < 0) throw new RangeError("sourceEnd out of bounds"); i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n); var o = i - n; if (this === t && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(r, n, i); else if (this === t && n < r && r < i) for (var s = o - 1; s >= 0; --s)t[s + r] = this[s + n]; else Uint8Array.prototype.set.call(t, this.subarray(n, i), r); return o }, e.prototype.fill = function (t, r, n, i) { if ("string" == typeof t) { if ("string" == typeof r ? (i = r, r = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string"); if ("string" == typeof i && !e.isEncoding(i)) throw new TypeError("Unknown encoding: " + i); if (1 === t.length) { var o = t.charCodeAt(0); ("utf8" === i && o < 128 || "latin1" === i) && (t = o) } } else "number" == typeof t && (t &= 255); if (r < 0 || this.length < r || this.length < n) throw new RangeError("Out of range index"); if (n <= r) return this; var s; if (r >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t) for (s = r; s < n; ++s)this[s] = t; else { var a = e.isBuffer(t) ? t : e.from(t, i), f = a.length; if (0 === f) throw new TypeError('The value "' + t + '" is invalid for argument "value"'); for (s = 0; s < n - r; ++s)this[s + r] = a[s % f] } return this }; var C = /[^+/0-9A-Za-z-_]/g; function M(t, e) { var r; e = e || 1 / 0; for (var n = t.length, i = null, o = [], s = 0; s < n; ++s) { if ((r = t.charCodeAt(s)) > 55295 && r < 57344) { if (!i) { if (r > 56319) { (e -= 3) > -1 && o.push(239, 191, 189); continue } if (s + 1 === n) { (e -= 3) > -1 && o.push(239, 191, 189); continue } i = r; continue } if (r < 56320) { (e -= 3) > -1 && o.push(239, 191, 189), i = r; continue } r = 65536 + (i - 55296 << 10 | r - 56320) } else i && (e -= 3) > -1 && o.push(239, 191, 189); if (i = null, r < 128) { if ((e -= 1) < 0) break; o.push(r) } else if (r < 2048) { if ((e -= 2) < 0) break; o.push(r >> 6 | 192, 63 & r | 128) } else if (r < 65536) { if ((e -= 3) < 0) break; o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128) } else { if (!(r < 1114112)) throw new Error("Invalid code point"); if ((e -= 4) < 0) break; o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128) } } return o } function z(t) { return n.toByteArray(function (t) { if ((t = (t = t.split("=")[0]).trim().replace(C, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function j(t, e, r, n) { for (var i = 0; i < n && !(i + r >= e.length || i >= t.length); ++i)e[i + r] = t[i]; return i } function D(t, e) { return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name } function F(t) { return t != t } }).call(this, t("buffer").Buffer) }, { "base64-js": 5, buffer: 9, ieee754: 12 }], 10: [function (t, e, r) { (function (t) { function e(t) { return Object.prototype.toString.call(t) } r.isArray = function (t) { return Array.isArray ? Array.isArray(t) : "[object Array]" === e(t) }, r.isBoolean = function (t) { return "boolean" == typeof t }, r.isNull = function (t) { return null === t }, r.isNullOrUndefined = function (t) { return null == t }, r.isNumber = function (t) { return "number" == typeof t }, r.isString = function (t) { return "string" == typeof t }, r.isSymbol = function (t) { return "symbol" == typeof t }, r.isUndefined = function (t) { return void 0 === t }, r.isRegExp = function (t) { return "[object RegExp]" === e(t) }, r.isObject = function (t) { return "object" == typeof t && null !== t }, r.isDate = function (t) { return "[object Date]" === e(t) }, r.isError = function (t) { return "[object Error]" === e(t) || t instanceof Error }, r.isFunction = function (t) { return "function" == typeof t }, r.isPrimitive = function (t) { return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t }, r.isBuffer = t.isBuffer }).call(this, { isBuffer: t("../../is-buffer/index.js") }) }, { "../../is-buffer/index.js": 14 }], 11: [function (t, e, r) { var n = Object.create || function (t) { var e = function () { }; return e.prototype = t, new e }, i = Object.keys || function (t) { var e = []; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.push(r); return r }, o = Function.prototype.bind || function (t) { var e = this; return function () { return e.apply(t, arguments) } }; function s() { this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = n(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 } e.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._maxListeners = void 0; var a, f = 10; try { var u = {}; Object.defineProperty && Object.defineProperty(u, "x", { value: 0 }), a = 0 === u.x } catch (t) { a = !1 } function l(t) { return void 0 === t._maxListeners ? s.defaultMaxListeners : t._maxListeners } function h(t, e, r) { if (e) t.call(r); else for (var n = t.length, i = v(t, n), o = 0; o < n; ++o)i[o].call(r) } function c(t, e, r, n) { if (e) t.call(r, n); else for (var i = t.length, o = v(t, i), s = 0; s < i; ++s)o[s].call(r, n) } function d(t, e, r, n, i) { if (e) t.call(r, n, i); else for (var o = t.length, s = v(t, o), a = 0; a < o; ++a)s[a].call(r, n, i) } function p(t, e, r, n, i, o) { if (e) t.call(r, n, i, o); else for (var s = t.length, a = v(t, s), f = 0; f < s; ++f)a[f].call(r, n, i, o) } function g(t, e, r, n) { if (e) t.apply(r, n); else for (var i = t.length, o = v(t, i), s = 0; s < i; ++s)o[s].apply(r, n) } function y(t, e, r, i) { var o, s, a; if ("function" != typeof r) throw new TypeError('"listener" argument must be a function'); if ((s = t._events) ? (s.newListener && (t.emit("newListener", e, r.listener ? r.listener : r), s = t._events), a = s[e]) : (s = t._events = n(null), t._eventsCount = 0), a) { if ("function" == typeof a ? a = s[e] = i ? [r, a] : [a, r] : i ? a.unshift(r) : a.push(r), !a.warned && (o = l(t)) && o > 0 && a.length > o) { a.warned = !0; var f = new Error("Possible EventEmitter memory leak detected. " + a.length + ' "' + String(e) + '" listeners added. Use emitter.setMaxListeners() to increase limit.'); f.name = "MaxListenersExceededWarning", f.emitter = t, f.type = e, f.count = a.length, "object" == typeof console && console.warn && console.warn("%s: %s", f.name, f.message) } } else a = s[e] = r, ++t._eventsCount; return t } function b() { if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) { case 0: return this.listener.call(this.target); case 1: return this.listener.call(this.target, arguments[0]); case 2: return this.listener.call(this.target, arguments[0], arguments[1]); case 3: return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]); default: for (var t = new Array(arguments.length), e = 0; e < t.length; ++e)t[e] = arguments[e]; this.listener.apply(this.target, t) } } function _(t, e, r) { var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, i = o.call(b, n); return i.listener = r, n.wrapFn = i, i } function m(t, e, r) { var n = t._events; if (!n) return []; var i = n[e]; return i ? "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function (t) { for (var e = new Array(t.length), r = 0; r < e.length; ++r)e[r] = t[r].listener || t[r]; return e }(i) : v(i, i.length) : [] } function w(t) { var e = this._events; if (e) { var r = e[t]; if ("function" == typeof r) return 1; if (r) return r.length } return 0 } function v(t, e) { for (var r = new Array(e), n = 0; n < e; ++n)r[n] = t[n]; return r } a ? Object.defineProperty(s, "defaultMaxListeners", { enumerable: !0, get: function () { return f }, set: function (t) { if ("number" != typeof t || t < 0 || t != t) throw new TypeError('"defaultMaxListeners" must be a positive number'); f = t } }) : s.defaultMaxListeners = f, s.prototype.setMaxListeners = function (t) { if ("number" != typeof t || t < 0 || isNaN(t)) throw new TypeError('"n" argument must be a positive number'); return this._maxListeners = t, this }, s.prototype.getMaxListeners = function () { return l(this) }, s.prototype.emit = function (t) { var e, r, n, i, o, s, a = "error" === t; if (s = this._events) a = a && null == s.error; else if (!a) return !1; if (a) { if (arguments.length > 1 && (e = arguments[1]), e instanceof Error) throw e; var f = new Error('Unhandled "error" event. (' + e + ")"); throw f.context = e, f } if (!(r = s[t])) return !1; var u = "function" == typeof r; switch (n = arguments.length) { case 1: h(r, u, this); break; case 2: c(r, u, this, arguments[1]); break; case 3: d(r, u, this, arguments[1], arguments[2]); break; case 4: p(r, u, this, arguments[1], arguments[2], arguments[3]); break; default: for (i = new Array(n - 1), o = 1; o < n; o++)i[o - 1] = arguments[o]; g(r, u, this, i) }return !0 }, s.prototype.addListener = function (t, e) { return y(this, t, e, !1) }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function (t, e) { return y(this, t, e, !0) }, s.prototype.once = function (t, e) { if ("function" != typeof e) throw new TypeError('"listener" argument must be a function'); return this.on(t, _(this, t, e)), this }, s.prototype.prependOnceListener = function (t, e) { if ("function" != typeof e) throw new TypeError('"listener" argument must be a function'); return this.prependListener(t, _(this, t, e)), this }, s.prototype.removeListener = function (t, e) { var r, i, o, s, a; if ("function" != typeof e) throw new TypeError('"listener" argument must be a function'); if (!(i = this._events)) return this; if (!(r = i[t])) return this; if (r === e || r.listener === e) 0 == --this._eventsCount ? this._events = n(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, r.listener || e)); else if ("function" != typeof r) { for (o = -1, s = r.length - 1; s >= 0; s--)if (r[s] === e || r[s].listener === e) { a = r[s].listener, o = s; break } if (o < 0) return this; 0 === o ? r.shift() : function (t, e) { for (var r = e, n = r + 1, i = t.length; n < i; r += 1, n += 1)t[r] = t[n]; t.pop() }(r, o), 1 === r.length && (i[t] = r[0]), i.removeListener && this.emit("removeListener", t, a || e) } return this }, s.prototype.removeAllListeners = function (t) { var e, r, o; if (!(r = this._events)) return this; if (!r.removeListener) return 0 === arguments.length ? (this._events = n(null), this._eventsCount = 0) : r[t] && (0 == --this._eventsCount ? this._events = n(null) : delete r[t]), this; if (0 === arguments.length) { var s, a = i(r); for (o = 0; o < a.length; ++o)"removeListener" !== (s = a[o]) && this.removeAllListeners(s); return this.removeAllListeners("removeListener"), this._events = n(null), this._eventsCount = 0, this } if ("function" == typeof (e = r[t])) this.removeListener(t, e); else if (e) for (o = e.length - 1; o >= 0; o--)this.removeListener(t, e[o]); return this }, s.prototype.listeners = function (t) { return m(this, t, !0) }, s.prototype.rawListeners = function (t) { return m(this, t, !1) }, s.listenerCount = function (t, e) { return "function" == typeof t.listenerCount ? t.listenerCount(e) : w.call(t, e) }, s.prototype.listenerCount = w, s.prototype.eventNames = function () { return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [] } }, {}], 12: [function (t, e, r) { r.read = function (t, e, r, n, i) { var o, s, a = 8 * i - n - 1, f = (1 << a) - 1, u = f >> 1, l = -7, h = r ? i - 1 : 0, c = r ? -1 : 1, d = t[e + h]; for (h += c, o = d & (1 << -l) - 1, d >>= -l, l += a; l > 0; o = 256 * o + t[e + h], h += c, l -= 8); for (s = o & (1 << -l) - 1, o >>= -l, l += n; l > 0; s = 256 * s + t[e + h], h += c, l -= 8); if (0 === o) o = 1 - u; else { if (o === f) return s ? NaN : 1 / 0 * (d ? -1 : 1); s += Math.pow(2, n), o -= u } return (d ? -1 : 1) * s * Math.pow(2, o - n) }, r.write = function (t, e, r, n, i, o) { var s, a, f, u = 8 * o - i - 1, l = (1 << u) - 1, h = l >> 1, c = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : o - 1, p = n ? 1 : -1, g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = l) : (s = Math.floor(Math.log(e) / Math.LN2), e * (f = Math.pow(2, -s)) < 1 && (s--, f *= 2), (e += s + h >= 1 ? c / f : c * Math.pow(2, 1 - h)) * f >= 2 && (s++, f /= 2), s + h >= l ? (a = 0, s = l) : s + h >= 1 ? (a = (e * f - 1) * Math.pow(2, i), s += h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; t[r + d] = 255 & a, d += p, a /= 256, i -= 8); for (s = s << i | a, u += i; u > 0; t[r + d] = 255 & s, d += p, s /= 256, u -= 8); t[r + d - p] |= 128 * g } }, {}], 13: [function (t, e, r) { "function" == typeof Object.create ? e.exports = function (t, e) { e && (t.super_ = e, t.prototype = Object.create(e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } })) } : e.exports = function (t, e) { if (e) { t.super_ = e; var r = function () { }; r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t } } }, {}], 14: [function (t, e, r) { function n(t) { return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t) } e.exports = function (t) { return null != t && (n(t) || function (t) { return "function" == typeof t.readFloatLE && "function" == typeof t.slice && n(t.slice(0, 0)) }(t) || !!t._isBuffer) } }, {}], 15: [function (t, e, r) { var n = {}.toString; e.exports = Array.isArray || function (t) { return "[object Array]" == n.call(t) } }, {}], 16: [function (t, e, r) { "use strict"; var n = Object.getOwnPropertySymbols, i = Object.prototype.hasOwnProperty, o = Object.prototype.propertyIsEnumerable; function s(t) { if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } e.exports = function () { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var e = {}, r = 0; r < 10; r++)e["_" + String.fromCharCode(r)] = r; if ("0123456789" !== Object.getOwnPropertyNames(e).map((function (t) { return e[t] })).join("")) return !1; var n = {}; return "abcdefghijklmnopqrst".split("").forEach((function (t) { n[t] = t })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("") } catch (t) { return !1 } }() ? Object.assign : function (t, e) { for (var r, a, f = s(t), u = 1; u < arguments.length; u++) { for (var l in r = Object(arguments[u])) i.call(r, l) && (f[l] = r[l]); if (n) { a = n(r); for (var h = 0; h < a.length; h++)o.call(r, a[h]) && (f[a[h]] = r[a[h]]) } } return f } }, {}], 17: [function (t, e, r) { "use strict"; var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; function i(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } r.assign = function (t) { for (var e = Array.prototype.slice.call(arguments, 1); e.length;) { var r = e.shift(); if (r) { if ("object" != typeof r) throw new TypeError(r + "must be non-object"); for (var n in r) i(r, n) && (t[n] = r[n]) } } return t }, r.shrinkBuf = function (t, e) { return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t) }; var o = { arraySet: function (t, e, r, n, i) { if (e.subarray && t.subarray) t.set(e.subarray(r, r + n), i); else for (var o = 0; o < n; o++)t[i + o] = e[r + o] }, flattenChunks: function (t) { var e, r, n, i, o, s; for (n = 0, e = 0, r = t.length; e < r; e++)n += t[e].length; for (s = new Uint8Array(n), i = 0, e = 0, r = t.length; e < r; e++)o = t[e], s.set(o, i), i += o.length; return s } }, s = { arraySet: function (t, e, r, n, i) { for (var o = 0; o < n; o++)t[i + o] = e[r + o] }, flattenChunks: function (t) { return [].concat.apply([], t) } }; r.setTyped = function (t) { t ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, o)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s)) }, r.setTyped(n) }, {}], 18: [function (t, e, r) { "use strict"; e.exports = function (t, e, r, n) { for (var i = 65535 & t | 0, o = t >>> 16 & 65535 | 0, s = 0; 0 !== r;) { r -= s = r > 2e3 ? 2e3 : r; do { o = o + (i = i + e[n++] | 0) | 0 } while (--s); i %= 65521, o %= 65521 } return i | o << 16 | 0 } }, {}], 19: [function (t, e, r) { "use strict"; e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 } }, {}], 20: [function (t, e, r) { "use strict"; var n = function () { for (var t, e = [], r = 0; r < 256; r++) { t = r; for (var n = 0; n < 8; n++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1; e[r] = t } return e }(); e.exports = function (t, e, r, i) { var o = n, s = i + r; t ^= -1; for (var a = i; a < s; a++)t = t >>> 8 ^ o[255 & (t ^ e[a])]; return -1 ^ t } }, {}], 21: [function (t, e, r) { "use strict"; var n, i = t("../utils/common"), o = t("./trees"), s = t("./adler32"), a = t("./crc32"), f = t("./messages"), u = -2, l = 258, h = 262, c = 103, d = 113, p = 666; function g(t, e) { return t.msg = f[e], e } function y(t) { return (t << 1) - (t > 4 ? 9 : 0) } function b(t) { for (var e = t.length; --e >= 0;)t[e] = 0 } function _(t) { var e = t.state, r = e.pending; r > t.avail_out && (r = t.avail_out), 0 !== r && (i.arraySet(t.output, e.pending_buf, e.pending_out, r, t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0)) } function m(t, e) { o._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, _(t.strm) } function w(t, e) { t.pending_buf[t.pending++] = e } function v(t, e) { t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e } function E(t, e) { var r, n, i = t.max_chain_length, o = t.strstart, s = t.prev_length, a = t.nice_match, f = t.strstart > t.w_size - h ? t.strstart - (t.w_size - h) : 0, u = t.window, c = t.w_mask, d = t.prev, p = t.strstart + l, g = u[o + s - 1], y = u[o + s]; t.prev_length >= t.good_match && (i >>= 2), a > t.lookahead && (a = t.lookahead); do { if (u[(r = e) + s] === y && u[r + s - 1] === g && u[r] === u[o] && u[++r] === u[o + 1]) { o += 2, r++; do { } while (u[++o] === u[++r] && u[++o] === u[++r] && u[++o] === u[++r] && u[++o] === u[++r] && u[++o] === u[++r] && u[++o] === u[++r] && u[++o] === u[++r] && u[++o] === u[++r] && o < p); if (n = l - (p - o), o = p - l, n > s) { if (t.match_start = e, s = n, n >= a) break; g = u[o + s - 1], y = u[o + s] } } } while ((e = d[e & c]) > f && 0 != --i); return s <= t.lookahead ? s : t.lookahead } function k(t) { var e, r, n, o, f, u, l, c, d, p, g = t.w_size; do { if (o = t.window_size - t.lookahead - t.strstart, t.strstart >= g + (g - h)) { i.arraySet(t.window, t.window, g, g, 0), t.match_start -= g, t.strstart -= g, t.block_start -= g, e = r = t.hash_size; do { n = t.head[--e], t.head[e] = n >= g ? n - g : 0 } while (--r); e = r = g; do { n = t.prev[--e], t.prev[e] = n >= g ? n - g : 0 } while (--r); o += g } if (0 === t.strm.avail_in) break; if (u = t.strm, l = t.window, c = t.strstart + t.lookahead, d = o, p = void 0, (p = u.avail_in) > d && (p = d), r = 0 === p ? 0 : (u.avail_in -= p, i.arraySet(l, u.input, u.next_in, p, c), 1 === u.state.wrap ? u.adler = s(u.adler, l, p, c) : 2 === u.state.wrap && (u.adler = a(u.adler, l, p, c)), u.next_in += p, u.total_in += p, p), t.lookahead += r, t.lookahead + t.insert >= 3) for (f = t.strstart - t.insert, t.ins_h = t.window[f], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[f + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[f + 3 - 1]) & t.hash_mask, t.prev[f & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = f, f++, t.insert--, !(t.lookahead + t.insert < 3));); } while (t.lookahead < h && 0 !== t.strm.avail_in) } function S(t, e) { for (var r, n; ;) { if (t.lookahead < h) { if (k(t), t.lookahead < h && 0 === e) return 1; if (0 === t.lookahead) break } if (r = 0, t.lookahead >= 3 && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - h && (t.match_length = E(t, r)), t.match_length >= 3) if (n = o._tr_tally(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= 3) { t.match_length--; do { t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart } while (0 != --t.match_length); t.strstart++ } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask; else n = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++; if (n && (m(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = t.strstart < 2 ? t.strstart : 2, 4 === e ? (m(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (m(t, !1), 0 === t.strm.avail_out) ? 1 : 2 } function x(t, e) { for (var r, n, i; ;) { if (t.lookahead < h) { if (k(t), t.lookahead < h && 0 === e) return 1; if (0 === t.lookahead) break } if (r = 0, t.lookahead >= 3 && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - h && (t.match_length = E(t, r), t.match_length <= 5 && (1 === t.strategy || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)), t.prev_length >= 3 && t.match_length <= t.prev_length) { i = t.strstart + t.lookahead - 3, n = o._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; do { ++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart) } while (0 != --t.prev_length); if (t.match_available = 0, t.match_length = 2, t.strstart++, n && (m(t, !1), 0 === t.strm.avail_out)) return 1 } else if (t.match_available) { if ((n = o._tr_tally(t, 0, t.window[t.strstart - 1])) && m(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1 } else t.match_available = 1, t.strstart++, t.lookahead-- } return t.match_available && (n = o._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < 2 ? t.strstart : 2, 4 === e ? (m(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (m(t, !1), 0 === t.strm.avail_out) ? 1 : 2 } function L(t, e, r, n, i) { this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = n, this.func = i } function A() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(1146), this.dyn_dtree = new i.Buf16(122), this.bl_tree = new i.Buf16(78), b(this.dyn_ltree), b(this.dyn_dtree), b(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(16), this.heap = new i.Buf16(573), b(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(573), b(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function B(t) { var e; return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = 2, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? 42 : d, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = 0, o._tr_init(e), 0) : g(t, u) } function T(t) { var e, r = B(t); return 0 === r && ((e = t.state).window_size = 2 * e.w_size, b(e.head), e.max_lazy_match = n[e.level].max_lazy, e.good_match = n[e.level].good_length, e.nice_match = n[e.level].nice_length, e.max_chain_length = n[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = 2, e.match_available = 0, e.ins_h = 0), r } function I(t, e, r, n, o, s) { if (!t) return u; var a = 1; if (-1 === e && (e = 6), n < 0 ? (a = 0, n = -n) : n > 15 && (a = 2, n -= 16), o < 1 || o > 9 || 8 !== r || n < 8 || n > 15 || e < 0 || e > 9 || s < 0 || s > 4) return g(t, u); 8 === n && (n = 9); var f = new A; return t.state = f, f.strm = t, f.wrap = a, f.gzhead = null, f.w_bits = n, f.w_size = 1 << f.w_bits, f.w_mask = f.w_size - 1, f.hash_bits = o + 7, f.hash_size = 1 << f.hash_bits, f.hash_mask = f.hash_size - 1, f.hash_shift = ~~((f.hash_bits + 3 - 1) / 3), f.window = new i.Buf8(2 * f.w_size), f.head = new i.Buf16(f.hash_size), f.prev = new i.Buf16(f.w_size), f.lit_bufsize = 1 << o + 6, f.pending_buf_size = 4 * f.lit_bufsize, f.pending_buf = new i.Buf8(f.pending_buf_size), f.d_buf = 1 * f.lit_bufsize, f.l_buf = 3 * f.lit_bufsize, f.level = e, f.strategy = s, f.method = r, T(t) } n = [new L(0, 0, 0, 0, (function (t, e) { var r = 65535; for (r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5); ;) { if (t.lookahead <= 1) { if (k(t), 0 === t.lookahead && 0 === e) return 1; if (0 === t.lookahead) break } t.strstart += t.lookahead, t.lookahead = 0; var n = t.block_start + r; if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, m(t, !1), 0 === t.strm.avail_out)) return 1; if (t.strstart - t.block_start >= t.w_size - h && (m(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = 0, 4 === e ? (m(t, !0), 0 === t.strm.avail_out ? 3 : 4) : (t.strstart > t.block_start && (m(t, !1), t.strm.avail_out), 1) })), new L(4, 4, 8, 4, S), new L(4, 5, 16, 8, S), new L(4, 6, 32, 32, S), new L(4, 4, 16, 16, x), new L(8, 16, 32, 32, x), new L(8, 16, 128, 128, x), new L(8, 32, 128, 256, x), new L(32, 128, 258, 1024, x), new L(32, 258, 258, 4096, x)], r.deflateInit = function (t, e) { return I(t, e, 8, 15, 8, 0) }, r.deflateInit2 = I, r.deflateReset = T, r.deflateResetKeep = B, r.deflateSetHeader = function (t, e) { return t && t.state ? 2 !== t.state.wrap ? u : (t.state.gzhead = e, 0) : u }, r.deflate = function (t, e) { var r, i, s, f; if (!t || !t.state || e > 5 || e < 0) return t ? g(t, u) : u; if (i = t.state, !t.output || !t.input && 0 !== t.avail_in || i.status === p && 4 !== e) return g(t, 0 === t.avail_out ? -5 : u); if (i.strm = t, r = i.last_flush, i.last_flush = e, 42 === i.status) if (2 === i.wrap) t.adler = 0, w(i, 31), w(i, 139), w(i, 8), i.gzhead ? (w(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), w(i, 255 & i.gzhead.time), w(i, i.gzhead.time >> 8 & 255), w(i, i.gzhead.time >> 16 & 255), w(i, i.gzhead.time >> 24 & 255), w(i, 9 === i.level ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), w(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (w(i, 255 & i.gzhead.extra.length), w(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = a(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69) : (w(i, 0), w(i, 0), w(i, 0), w(i, 0), w(i, 0), w(i, 9 === i.level ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), w(i, 3), i.status = d); else { var h = 8 + (i.w_bits - 8 << 4) << 8; h |= (i.strategy >= 2 || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3) << 6, 0 !== i.strstart && (h |= 32), h += 31 - h % 31, i.status = d, v(i, h), 0 !== i.strstart && (v(i, t.adler >>> 16), v(i, 65535 & t.adler)), t.adler = 1 } if (69 === i.status) if (i.gzhead.extra) { for (s = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), _(t), s = i.pending, i.pending !== i.pending_buf_size));)w(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++; i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = 73) } else i.status = 73; if (73 === i.status) if (i.gzhead.name) { s = i.pending; do { if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), _(t), s = i.pending, i.pending === i.pending_buf_size)) { f = 1; break } f = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, w(i, f) } while (0 !== f); i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), 0 === f && (i.gzindex = 0, i.status = 91) } else i.status = 91; if (91 === i.status) if (i.gzhead.comment) { s = i.pending; do { if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), _(t), s = i.pending, i.pending === i.pending_buf_size)) { f = 1; break } f = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, w(i, f) } while (0 !== f); i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), 0 === f && (i.status = c) } else i.status = c; if (i.status === c && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && _(t), i.pending + 2 <= i.pending_buf_size && (w(i, 255 & t.adler), w(i, t.adler >> 8 & 255), t.adler = 0, i.status = d)) : i.status = d), 0 !== i.pending) { if (_(t), 0 === t.avail_out) return i.last_flush = -1, 0 } else if (0 === t.avail_in && y(e) <= y(r) && 4 !== e) return g(t, -5); if (i.status === p && 0 !== t.avail_in) return g(t, -5); if (0 !== t.avail_in || 0 !== i.lookahead || 0 !== e && i.status !== p) { var E = 2 === i.strategy ? function (t, e) { for (var r; ;) { if (0 === t.lookahead && (k(t), 0 === t.lookahead)) { if (0 === e) return 1; break } if (t.match_length = 0, r = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (m(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = 0, 4 === e ? (m(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (m(t, !1), 0 === t.strm.avail_out) ? 1 : 2 }(i, e) : 3 === i.strategy ? function (t, e) { for (var r, n, i, s, a = t.window; ;) { if (t.lookahead <= l) { if (k(t), t.lookahead <= l && 0 === e) return 1; if (0 === t.lookahead) break } if (t.match_length = 0, t.lookahead >= 3 && t.strstart > 0 && (n = a[i = t.strstart - 1]) === a[++i] && n === a[++i] && n === a[++i]) { s = t.strstart + l; do { } while (n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && i < s); t.match_length = l - (s - i), t.match_length > t.lookahead && (t.match_length = t.lookahead) } if (t.match_length >= 3 ? (r = o._tr_tally(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && (m(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = 0, 4 === e ? (m(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (m(t, !1), 0 === t.strm.avail_out) ? 1 : 2 }(i, e) : n[i.level].func(i, e); if (3 !== E && 4 !== E || (i.status = p), 1 === E || 3 === E) return 0 === t.avail_out && (i.last_flush = -1), 0; if (2 === E && (1 === e ? o._tr_align(i) : 5 !== e && (o._tr_stored_block(i, 0, 0, !1), 3 === e && (b(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), _(t), 0 === t.avail_out)) return i.last_flush = -1, 0 } return 4 !== e ? 0 : i.wrap <= 0 ? 1 : (2 === i.wrap ? (w(i, 255 & t.adler), w(i, t.adler >> 8 & 255), w(i, t.adler >> 16 & 255), w(i, t.adler >> 24 & 255), w(i, 255 & t.total_in), w(i, t.total_in >> 8 & 255), w(i, t.total_in >> 16 & 255), w(i, t.total_in >> 24 & 255)) : (v(i, t.adler >>> 16), v(i, 65535 & t.adler)), _(t), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? 0 : 1) }, r.deflateEnd = function (t) { var e; return t && t.state ? 42 !== (e = t.state.status) && 69 !== e && 73 !== e && 91 !== e && e !== c && e !== d && e !== p ? g(t, u) : (t.state = null, e === d ? g(t, -3) : 0) : u }, r.deflateSetDictionary = function (t, e) { var r, n, o, a, f, l, h, c, d = e.length; if (!t || !t.state) return u; if (2 === (a = (r = t.state).wrap) || 1 === a && 42 !== r.status || r.lookahead) return u; for (1 === a && (t.adler = s(t.adler, e, d, 0)), r.wrap = 0, d >= r.w_size && (0 === a && (b(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), c = new i.Buf8(r.w_size), i.arraySet(c, e, d - r.w_size, r.w_size, 0), e = c, d = r.w_size), f = t.avail_in, l = t.next_in, h = t.input, t.avail_in = d, t.next_in = 0, t.input = e, k(r); r.lookahead >= 3;) { n = r.strstart, o = r.lookahead - 2; do { r.ins_h = (r.ins_h << r.hash_shift ^ r.window[n + 3 - 1]) & r.hash_mask, r.prev[n & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = n, n++ } while (--o); r.strstart = n, r.lookahead = 2, k(r) } return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = 2, r.match_available = 0, t.next_in = l, t.input = h, t.avail_in = f, r.wrap = a, 0 }, r.deflateInfo = "pako deflate (from Nodeca project)" }, { "../utils/common": 17, "./adler32": 18, "./crc32": 20, "./messages": 25, "./trees": 26 }], 22: [function (t, e, r) { "use strict"; e.exports = function (t, e) { var r, n, i, o, s, a, f, u, l, h, c, d, p, g, y, b, _, m, w, v, E, k, S, x, L; r = t.state, n = t.next_in, x = t.input, i = n + (t.avail_in - 5), o = t.next_out, L = t.output, s = o - (e - t.avail_out), a = o + (t.avail_out - 257), f = r.dmax, u = r.wsize, l = r.whave, h = r.wnext, c = r.window, d = r.hold, p = r.bits, g = r.lencode, y = r.distcode, b = (1 << r.lenbits) - 1, _ = (1 << r.distbits) - 1; t: do { p < 15 && (d += x[n++] << p, p += 8, d += x[n++] << p, p += 8), m = g[d & b]; e: for (; ;) { if (d >>>= w = m >>> 24, p -= w, 0 == (w = m >>> 16 & 255)) L[o++] = 65535 & m; else { if (!(16 & w)) { if (0 == (64 & w)) { m = g[(65535 & m) + (d & (1 << w) - 1)]; continue e } if (32 & w) { r.mode = 12; break t } t.msg = "invalid literal/length code", r.mode = 30; break t } v = 65535 & m, (w &= 15) && (p < w && (d += x[n++] << p, p += 8), v += d & (1 << w) - 1, d >>>= w, p -= w), p < 15 && (d += x[n++] << p, p += 8, d += x[n++] << p, p += 8), m = y[d & _]; r: for (; ;) { if (d >>>= w = m >>> 24, p -= w, !(16 & (w = m >>> 16 & 255))) { if (0 == (64 & w)) { m = y[(65535 & m) + (d & (1 << w) - 1)]; continue r } t.msg = "invalid distance code", r.mode = 30; break t } if (E = 65535 & m, p < (w &= 15) && (d += x[n++] << p, (p += 8) < w && (d += x[n++] << p, p += 8)), (E += d & (1 << w) - 1) > f) { t.msg = "invalid distance too far back", r.mode = 30; break t } if (d >>>= w, p -= w, E > (w = o - s)) { if ((w = E - w) > l && r.sane) { t.msg = "invalid distance too far back", r.mode = 30; break t } if (k = 0, S = c, 0 === h) { if (k += u - w, w < v) { v -= w; do { L[o++] = c[k++] } while (--w); k = o - E, S = L } } else if (h < w) { if (k += u + h - w, (w -= h) < v) { v -= w; do { L[o++] = c[k++] } while (--w); if (k = 0, h < v) { v -= w = h; do { L[o++] = c[k++] } while (--w); k = o - E, S = L } } } else if (k += h - w, w < v) { v -= w; do { L[o++] = c[k++] } while (--w); k = o - E, S = L } for (; v > 2;)L[o++] = S[k++], L[o++] = S[k++], L[o++] = S[k++], v -= 3; v && (L[o++] = S[k++], v > 1 && (L[o++] = S[k++])) } else { k = o - E; do { L[o++] = L[k++], L[o++] = L[k++], L[o++] = L[k++], v -= 3 } while (v > 2); v && (L[o++] = L[k++], v > 1 && (L[o++] = L[k++])) } break } } break } } while (n < i && o < a); n -= v = p >> 3, d &= (1 << (p -= v << 3)) - 1, t.next_in = n, t.next_out = o, t.avail_in = n < i ? i - n + 5 : 5 - (n - i), t.avail_out = o < a ? a - o + 257 : 257 - (o - a), r.hold = d, r.bits = p } }, {}], 23: [function (t, e, r) { "use strict"; var n = t("../utils/common"), i = t("./adler32"), o = t("./crc32"), s = t("./inffast"), a = t("./inftrees"), f = -2, u = 12, l = 30; function h(t) { return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24) } function c() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } function d(t) { var e; return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = 1, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new n.Buf32(852), e.distcode = e.distdyn = new n.Buf32(592), e.sane = 1, e.back = -1, 0) : f } function p(t) { var e; return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, d(t)) : f } function g(t, e) { var r, n; return t && t.state ? (n = t.state, e < 0 ? (r = 0, e = -e) : (r = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? f : (null !== n.window && n.wbits !== e && (n.window = null), n.wrap = r, n.wbits = e, p(t))) : f } function y(t, e) { var r, n; return t ? (n = new c, t.state = n, n.window = null, 0 !== (r = g(t, e)) && (t.state = null), r) : f } var b, _, m = !0; function w(t) { if (m) { var e; for (b = new n.Buf32(512), _ = new n.Buf32(32), e = 0; e < 144;)t.lens[e++] = 8; for (; e < 256;)t.lens[e++] = 9; for (; e < 280;)t.lens[e++] = 7; for (; e < 288;)t.lens[e++] = 8; for (a(1, t.lens, 0, 288, b, 0, t.work, { bits: 9 }), e = 0; e < 32;)t.lens[e++] = 5; a(2, t.lens, 0, 32, _, 0, t.work, { bits: 5 }), m = !1 } t.lencode = b, t.lenbits = 9, t.distcode = _, t.distbits = 5 } function v(t, e, r, i) { var o, s = t.state; return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new n.Buf8(s.wsize)), i >= s.wsize ? (n.arraySet(s.window, e, r - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize) : ((o = s.wsize - s.wnext) > i && (o = i), n.arraySet(s.window, e, r - i, o, s.wnext), (i -= o) ? (n.arraySet(s.window, e, r - i, i, 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += o, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += o))), 0 } r.inflateReset = p, r.inflateReset2 = g, r.inflateResetKeep = d, r.inflateInit = function (t) { return y(t, 15) }, r.inflateInit2 = y, r.inflate = function (t, e) { var r, c, d, p, g, y, b, _, m, E, k, S, x, L, A, B, T, I, R, O, U, N, C, M, z = 0, j = new n.Buf8(4), D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return f; (r = t.state).mode === u && (r.mode = 13), g = t.next_out, d = t.output, b = t.avail_out, p = t.next_in, c = t.input, y = t.avail_in, _ = r.hold, m = r.bits, E = y, k = b, N = 0; t: for (; ;)switch (r.mode) { case 1: if (0 === r.wrap) { r.mode = 13; break } for (; m < 16;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (2 & r.wrap && 35615 === _) { r.check = 0, j[0] = 255 & _, j[1] = _ >>> 8 & 255, r.check = o(r.check, j, 2, 0), _ = 0, m = 0, r.mode = 2; break } if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & _) << 8) + (_ >> 8)) % 31) { t.msg = "incorrect header check", r.mode = l; break } if (8 != (15 & _)) { t.msg = "unknown compression method", r.mode = l; break } if (m -= 4, U = 8 + (15 & (_ >>>= 4)), 0 === r.wbits) r.wbits = U; else if (U > r.wbits) { t.msg = "invalid window size", r.mode = l; break } r.dmax = 1 << U, t.adler = r.check = 1, r.mode = 512 & _ ? 10 : u, _ = 0, m = 0; break; case 2: for (; m < 16;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (r.flags = _, 8 != (255 & r.flags)) { t.msg = "unknown compression method", r.mode = l; break } if (57344 & r.flags) { t.msg = "unknown header flags set", r.mode = l; break } r.head && (r.head.text = _ >> 8 & 1), 512 & r.flags && (j[0] = 255 & _, j[1] = _ >>> 8 & 255, r.check = o(r.check, j, 2, 0)), _ = 0, m = 0, r.mode = 3; case 3: for (; m < 32;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } r.head && (r.head.time = _), 512 & r.flags && (j[0] = 255 & _, j[1] = _ >>> 8 & 255, j[2] = _ >>> 16 & 255, j[3] = _ >>> 24 & 255, r.check = o(r.check, j, 4, 0)), _ = 0, m = 0, r.mode = 4; case 4: for (; m < 16;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } r.head && (r.head.xflags = 255 & _, r.head.os = _ >> 8), 512 & r.flags && (j[0] = 255 & _, j[1] = _ >>> 8 & 255, r.check = o(r.check, j, 2, 0)), _ = 0, m = 0, r.mode = 5; case 5: if (1024 & r.flags) { for (; m < 16;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } r.length = _, r.head && (r.head.extra_len = _), 512 & r.flags && (j[0] = 255 & _, j[1] = _ >>> 8 & 255, r.check = o(r.check, j, 2, 0)), _ = 0, m = 0 } else r.head && (r.head.extra = null); r.mode = 6; case 6: if (1024 & r.flags && ((S = r.length) > y && (S = y), S && (r.head && (U = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), n.arraySet(r.head.extra, c, p, S, U)), 512 & r.flags && (r.check = o(r.check, c, S, p)), y -= S, p += S, r.length -= S), r.length)) break t; r.length = 0, r.mode = 7; case 7: if (2048 & r.flags) { if (0 === y) break t; S = 0; do { U = c[p + S++], r.head && U && r.length < 65536 && (r.head.name += String.fromCharCode(U)) } while (U && S < y); if (512 & r.flags && (r.check = o(r.check, c, S, p)), y -= S, p += S, U) break t } else r.head && (r.head.name = null); r.length = 0, r.mode = 8; case 8: if (4096 & r.flags) { if (0 === y) break t; S = 0; do { U = c[p + S++], r.head && U && r.length < 65536 && (r.head.comment += String.fromCharCode(U)) } while (U && S < y); if (512 & r.flags && (r.check = o(r.check, c, S, p)), y -= S, p += S, U) break t } else r.head && (r.head.comment = null); r.mode = 9; case 9: if (512 & r.flags) { for (; m < 16;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (_ !== (65535 & r.check)) { t.msg = "header crc mismatch", r.mode = l; break } _ = 0, m = 0 } r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = u; break; case 10: for (; m < 32;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } t.adler = r.check = h(_), _ = 0, m = 0, r.mode = 11; case 11: if (0 === r.havedict) return t.next_out = g, t.avail_out = b, t.next_in = p, t.avail_in = y, r.hold = _, r.bits = m, 2; t.adler = r.check = 1, r.mode = u; case u: if (5 === e || 6 === e) break t; case 13: if (r.last) { _ >>>= 7 & m, m -= 7 & m, r.mode = 27; break } for (; m < 3;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } switch (r.last = 1 & _, m -= 1, 3 & (_ >>>= 1)) { case 0: r.mode = 14; break; case 1: if (w(r), r.mode = 20, 6 === e) { _ >>>= 2, m -= 2; break t } break; case 2: r.mode = 17; break; case 3: t.msg = "invalid block type", r.mode = l }_ >>>= 2, m -= 2; break; case 14: for (_ >>>= 7 & m, m -= 7 & m; m < 32;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if ((65535 & _) != (_ >>> 16 ^ 65535)) { t.msg = "invalid stored block lengths", r.mode = l; break } if (r.length = 65535 & _, _ = 0, m = 0, r.mode = 15, 6 === e) break t; case 15: r.mode = 16; case 16: if (S = r.length) { if (S > y && (S = y), S > b && (S = b), 0 === S) break t; n.arraySet(d, c, p, S, g), y -= S, p += S, b -= S, g += S, r.length -= S; break } r.mode = u; break; case 17: for (; m < 14;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (r.nlen = 257 + (31 & _), _ >>>= 5, m -= 5, r.ndist = 1 + (31 & _), _ >>>= 5, m -= 5, r.ncode = 4 + (15 & _), _ >>>= 4, m -= 4, r.nlen > 286 || r.ndist > 30) { t.msg = "too many length or distance symbols", r.mode = l; break } r.have = 0, r.mode = 18; case 18: for (; r.have < r.ncode;) { for (; m < 3;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } r.lens[D[r.have++]] = 7 & _, _ >>>= 3, m -= 3 } for (; r.have < 19;)r.lens[D[r.have++]] = 0; if (r.lencode = r.lendyn, r.lenbits = 7, C = { bits: r.lenbits }, N = a(0, r.lens, 0, 19, r.lencode, 0, r.work, C), r.lenbits = C.bits, N) { t.msg = "invalid code lengths set", r.mode = l; break } r.have = 0, r.mode = 19; case 19: for (; r.have < r.nlen + r.ndist;) { for (; B = (z = r.lencode[_ & (1 << r.lenbits) - 1]) >>> 16 & 255, T = 65535 & z, !((A = z >>> 24) <= m);) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (T < 16) _ >>>= A, m -= A, r.lens[r.have++] = T; else { if (16 === T) { for (M = A + 2; m < M;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (_ >>>= A, m -= A, 0 === r.have) { t.msg = "invalid bit length repeat", r.mode = l; break } U = r.lens[r.have - 1], S = 3 + (3 & _), _ >>>= 2, m -= 2 } else if (17 === T) { for (M = A + 3; m < M;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } m -= A, U = 0, S = 3 + (7 & (_ >>>= A)), _ >>>= 3, m -= 3 } else { for (M = A + 7; m < M;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } m -= A, U = 0, S = 11 + (127 & (_ >>>= A)), _ >>>= 7, m -= 7 } if (r.have + S > r.nlen + r.ndist) { t.msg = "invalid bit length repeat", r.mode = l; break } for (; S--;)r.lens[r.have++] = U } } if (r.mode === l) break; if (0 === r.lens[256]) { t.msg = "invalid code -- missing end-of-block", r.mode = l; break } if (r.lenbits = 9, C = { bits: r.lenbits }, N = a(1, r.lens, 0, r.nlen, r.lencode, 0, r.work, C), r.lenbits = C.bits, N) { t.msg = "invalid literal/lengths set", r.mode = l; break } if (r.distbits = 6, r.distcode = r.distdyn, C = { bits: r.distbits }, N = a(2, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, C), r.distbits = C.bits, N) { t.msg = "invalid distances set", r.mode = l; break } if (r.mode = 20, 6 === e) break t; case 20: r.mode = 21; case 21: if (y >= 6 && b >= 258) { t.next_out = g, t.avail_out = b, t.next_in = p, t.avail_in = y, r.hold = _, r.bits = m, s(t, k), g = t.next_out, d = t.output, b = t.avail_out, p = t.next_in, c = t.input, y = t.avail_in, _ = r.hold, m = r.bits, r.mode === u && (r.back = -1); break } for (r.back = 0; B = (z = r.lencode[_ & (1 << r.lenbits) - 1]) >>> 16 & 255, T = 65535 & z, !((A = z >>> 24) <= m);) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (B && 0 == (240 & B)) { for (I = A, R = B, O = T; B = (z = r.lencode[O + ((_ & (1 << I + R) - 1) >> I)]) >>> 16 & 255, T = 65535 & z, !(I + (A = z >>> 24) <= m);) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } _ >>>= I, m -= I, r.back += I } if (_ >>>= A, m -= A, r.back += A, r.length = T, 0 === B) { r.mode = 26; break } if (32 & B) { r.back = -1, r.mode = u; break } if (64 & B) { t.msg = "invalid literal/length code", r.mode = l; break } r.extra = 15 & B, r.mode = 22; case 22: if (r.extra) { for (M = r.extra; m < M;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } r.length += _ & (1 << r.extra) - 1, _ >>>= r.extra, m -= r.extra, r.back += r.extra } r.was = r.length, r.mode = 23; case 23: for (; B = (z = r.distcode[_ & (1 << r.distbits) - 1]) >>> 16 & 255, T = 65535 & z, !((A = z >>> 24) <= m);) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (0 == (240 & B)) { for (I = A, R = B, O = T; B = (z = r.distcode[O + ((_ & (1 << I + R) - 1) >> I)]) >>> 16 & 255, T = 65535 & z, !(I + (A = z >>> 24) <= m);) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } _ >>>= I, m -= I, r.back += I } if (_ >>>= A, m -= A, r.back += A, 64 & B) { t.msg = "invalid distance code", r.mode = l; break } r.offset = T, r.extra = 15 & B, r.mode = 24; case 24: if (r.extra) { for (M = r.extra; m < M;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } r.offset += _ & (1 << r.extra) - 1, _ >>>= r.extra, m -= r.extra, r.back += r.extra } if (r.offset > r.dmax) { t.msg = "invalid distance too far back", r.mode = l; break } r.mode = 25; case 25: if (0 === b) break t; if (S = k - b, r.offset > S) { if ((S = r.offset - S) > r.whave && r.sane) { t.msg = "invalid distance too far back", r.mode = l; break } S > r.wnext ? (S -= r.wnext, x = r.wsize - S) : x = r.wnext - S, S > r.length && (S = r.length), L = r.window } else L = d, x = g - r.offset, S = r.length; S > b && (S = b), b -= S, r.length -= S; do { d[g++] = L[x++] } while (--S); 0 === r.length && (r.mode = 21); break; case 26: if (0 === b) break t; d[g++] = r.length, b--, r.mode = 21; break; case 27: if (r.wrap) { for (; m < 32;) { if (0 === y) break t; y--, _ |= c[p++] << m, m += 8 } if (k -= b, t.total_out += k, r.total += k, k && (t.adler = r.check = r.flags ? o(r.check, d, k, g - k) : i(r.check, d, k, g - k)), k = b, (r.flags ? _ : h(_)) !== r.check) { t.msg = "incorrect data check", r.mode = l; break } _ = 0, m = 0 } r.mode = 28; case 28: if (r.wrap && r.flags) { for (; m < 32;) { if (0 === y) break t; y--, _ += c[p++] << m, m += 8 } if (_ !== (4294967295 & r.total)) { t.msg = "incorrect length check", r.mode = l; break } _ = 0, m = 0 } r.mode = 29; case 29: N = 1; break t; case l: N = -3; break t; case 31: return -4; default: return f }return t.next_out = g, t.avail_out = b, t.next_in = p, t.avail_in = y, r.hold = _, r.bits = m, (r.wsize || k !== t.avail_out && r.mode < l && (r.mode < 27 || 4 !== e)) && v(t, t.output, t.next_out, k - t.avail_out) ? (r.mode = 31, -4) : (E -= t.avail_in, k -= t.avail_out, t.total_in += E, t.total_out += k, r.total += k, r.wrap && k && (t.adler = r.check = r.flags ? o(r.check, d, k, t.next_out - k) : i(r.check, d, k, t.next_out - k)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === u ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 === E && 0 === k || 4 === e) && 0 === N && (N = -5), N) }, r.inflateEnd = function (t) { if (!t || !t.state) return f; var e = t.state; return e.window && (e.window = null), t.state = null, 0 }, r.inflateGetHeader = function (t, e) { var r; return t && t.state ? 0 == (2 & (r = t.state).wrap) ? f : (r.head = e, e.done = !1, 0) : f }, r.inflateSetDictionary = function (t, e) { var r, n = e.length; return t && t.state ? 0 !== (r = t.state).wrap && 11 !== r.mode ? f : 11 === r.mode && i(1, e, n, 0) !== r.check ? -3 : v(t, e, n, n) ? (r.mode = 31, -4) : (r.havedict = 1, 0) : f }, r.inflateInfo = "pako inflate (from Nodeca project)" }, { "../utils/common": 17, "./adler32": 18, "./crc32": 20, "./inffast": 22, "./inftrees": 24 }], 24: [function (t, e, r) { "use strict"; var n = t("../utils/common"), i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], a = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; e.exports = function (t, e, r, f, u, l, h, c) { var d, p, g, y, b, _, m, w, v, E = c.bits, k = 0, S = 0, x = 0, L = 0, A = 0, B = 0, T = 0, I = 0, R = 0, O = 0, U = null, N = 0, C = new n.Buf16(16), M = new n.Buf16(16), z = null, j = 0; for (k = 0; k <= 15; k++)C[k] = 0; for (S = 0; S < f; S++)C[e[r + S]]++; for (A = E, L = 15; L >= 1 && 0 === C[L]; L--); if (A > L && (A = L), 0 === L) return u[l++] = 20971520, u[l++] = 20971520, c.bits = 1, 0; for (x = 1; x < L && 0 === C[x]; x++); for (A < x && (A = x), I = 1, k = 1; k <= 15; k++)if (I <<= 1, (I -= C[k]) < 0) return -1; if (I > 0 && (0 === t || 1 !== L)) return -1; for (M[1] = 0, k = 1; k < 15; k++)M[k + 1] = M[k] + C[k]; for (S = 0; S < f; S++)0 !== e[r + S] && (h[M[e[r + S]]++] = S); if (0 === t ? (U = z = h, _ = 19) : 1 === t ? (U = i, N -= 257, z = o, j -= 257, _ = 256) : (U = s, z = a, _ = -1), O = 0, S = 0, k = x, b = l, B = A, T = 0, g = -1, y = (R = 1 << A) - 1, 1 === t && R > 852 || 2 === t && R > 592) return 1; for (; ;) { m = k - T, h[S] < _ ? (w = 0, v = h[S]) : h[S] > _ ? (w = z[j + h[S]], v = U[N + h[S]]) : (w = 96, v = 0), d = 1 << k - T, x = p = 1 << B; do { u[b + (O >> T) + (p -= d)] = m << 24 | w << 16 | v | 0 } while (0 !== p); for (d = 1 << k - 1; O & d;)d >>= 1; if (0 !== d ? (O &= d - 1, O += d) : O = 0, S++, 0 == --C[k]) { if (k === L) break; k = e[r + h[S]] } if (k > A && (O & y) !== g) { for (0 === T && (T = A), b += x, I = 1 << (B = k - T); B + T < L && !((I -= C[B + T]) <= 0);)B++, I <<= 1; if (R += 1 << B, 1 === t && R > 852 || 2 === t && R > 592) return 1; u[g = O & y] = A << 24 | B << 16 | b - l | 0 } } return 0 !== O && (u[b + O] = k - T << 24 | 64 << 16 | 0), c.bits = A, 0 } }, { "../utils/common": 17 }], 25: [function (t, e, r) { "use strict"; e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" } }, {}], 26: [function (t, e, r) { "use strict"; var n = t("../utils/common"); function i(t) { for (var e = t.length; --e >= 0;)t[e] = 0 } var o = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], s = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], f = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], u = new Array(576); i(u); var l = new Array(60); i(l); var h = new Array(512); i(h); var c = new Array(256); i(c); var d = new Array(29); i(d); var p, g, y, b = new Array(30); function _(t, e, r, n, i) { this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = t && t.length } function m(t, e) { this.dyn_tree = t, this.max_code = 0, this.stat_desc = e } function w(t) { return t < 256 ? h[t] : h[256 + (t >>> 7)] } function v(t, e) { t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255 } function E(t, e, r) { t.bi_valid > 16 - r ? (t.bi_buf |= e << t.bi_valid & 65535, v(t, t.bi_buf), t.bi_buf = e >> 16 - t.bi_valid, t.bi_valid += r - 16) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r) } function k(t, e, r) { E(t, r[2 * e], r[2 * e + 1]) } function S(t, e) { var r = 0; do { r |= 1 & t, t >>>= 1, r <<= 1 } while (--e > 0); return r >>> 1 } function x(t, e, r) { var n, i, o = new Array(16), s = 0; for (n = 1; n <= 15; n++)o[n] = s = s + r[n - 1] << 1; for (i = 0; i <= e; i++) { var a = t[2 * i + 1]; 0 !== a && (t[2 * i] = S(o[a]++, a)) } } function L(t) { var e; for (e = 0; e < 286; e++)t.dyn_ltree[2 * e] = 0; for (e = 0; e < 30; e++)t.dyn_dtree[2 * e] = 0; for (e = 0; e < 19; e++)t.bl_tree[2 * e] = 0; t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0 } function A(t) { t.bi_valid > 8 ? v(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0 } function B(t, e, r, n) { var i = 2 * e, o = 2 * r; return t[i] < t[o] || t[i] === t[o] && n[e] <= n[r] } function T(t, e, r) { for (var n = t.heap[r], i = r << 1; i <= t.heap_len && (i < t.heap_len && B(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !B(e, n, t.heap[i], t.depth));)t.heap[r] = t.heap[i], r = i, i <<= 1; t.heap[r] = n } function I(t, e, r) { var n, i, a, f, u = 0; if (0 !== t.last_lit) do { n = t.pending_buf[t.d_buf + 2 * u] << 8 | t.pending_buf[t.d_buf + 2 * u + 1], i = t.pending_buf[t.l_buf + u], u++, 0 === n ? k(t, i, e) : (k(t, (a = c[i]) + 256 + 1, e), 0 !== (f = o[a]) && E(t, i -= d[a], f), k(t, a = w(--n), r), 0 !== (f = s[a]) && E(t, n -= b[a], f)) } while (u < t.last_lit); k(t, 256, e) } function R(t, e) { var r, n, i, o = e.dyn_tree, s = e.stat_desc.static_tree, a = e.stat_desc.has_stree, f = e.stat_desc.elems, u = -1; for (t.heap_len = 0, t.heap_max = 573, r = 0; r < f; r++)0 !== o[2 * r] ? (t.heap[++t.heap_len] = u = r, t.depth[r] = 0) : o[2 * r + 1] = 0; for (; t.heap_len < 2;)o[2 * (i = t.heap[++t.heap_len] = u < 2 ? ++u : 0)] = 1, t.depth[i] = 0, t.opt_len--, a && (t.static_len -= s[2 * i + 1]); for (e.max_code = u, r = t.heap_len >> 1; r >= 1; r--)T(t, o, r); i = f; do { r = t.heap[1], t.heap[1] = t.heap[t.heap_len--], T(t, o, 1), n = t.heap[1], t.heap[--t.heap_max] = r, t.heap[--t.heap_max] = n, o[2 * i] = o[2 * r] + o[2 * n], t.depth[i] = (t.depth[r] >= t.depth[n] ? t.depth[r] : t.depth[n]) + 1, o[2 * r + 1] = o[2 * n + 1] = i, t.heap[1] = i++, T(t, o, 1) } while (t.heap_len >= 2); t.heap[--t.heap_max] = t.heap[1], function (t, e) { var r, n, i, o, s, a, f = e.dyn_tree, u = e.max_code, l = e.stat_desc.static_tree, h = e.stat_desc.has_stree, c = e.stat_desc.extra_bits, d = e.stat_desc.extra_base, p = e.stat_desc.max_length, g = 0; for (o = 0; o <= 15; o++)t.bl_count[o] = 0; for (f[2 * t.heap[t.heap_max] + 1] = 0, r = t.heap_max + 1; r < 573; r++)(o = f[2 * f[2 * (n = t.heap[r]) + 1] + 1] + 1) > p && (o = p, g++), f[2 * n + 1] = o, n > u || (t.bl_count[o]++, s = 0, n >= d && (s = c[n - d]), a = f[2 * n], t.opt_len += a * (o + s), h && (t.static_len += a * (l[2 * n + 1] + s))); if (0 !== g) { do { for (o = p - 1; 0 === t.bl_count[o];)o--; t.bl_count[o]--, t.bl_count[o + 1] += 2, t.bl_count[p]--, g -= 2 } while (g > 0); for (o = p; 0 !== o; o--)for (n = t.bl_count[o]; 0 !== n;)(i = t.heap[--r]) > u || (f[2 * i + 1] !== o && (t.opt_len += (o - f[2 * i + 1]) * f[2 * i], f[2 * i + 1] = o), n--) } }(t, e), x(o, u, t.bl_count) } function O(t, e, r) { var n, i, o = -1, s = e[1], a = 0, f = 7, u = 4; for (0 === s && (f = 138, u = 3), e[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++)i = s, s = e[2 * (n + 1) + 1], ++a < f && i === s || (a < u ? t.bl_tree[2 * i] += a : 0 !== i ? (i !== o && t.bl_tree[2 * i]++, t.bl_tree[32]++) : a <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++, a = 0, o = i, 0 === s ? (f = 138, u = 3) : i === s ? (f = 6, u = 3) : (f = 7, u = 4)) } function U(t, e, r) { var n, i, o = -1, s = e[1], a = 0, f = 7, u = 4; for (0 === s && (f = 138, u = 3), n = 0; n <= r; n++)if (i = s, s = e[2 * (n + 1) + 1], !(++a < f && i === s)) { if (a < u) do { k(t, i, t.bl_tree) } while (0 != --a); else 0 !== i ? (i !== o && (k(t, i, t.bl_tree), a--), k(t, 16, t.bl_tree), E(t, a - 3, 2)) : a <= 10 ? (k(t, 17, t.bl_tree), E(t, a - 3, 3)) : (k(t, 18, t.bl_tree), E(t, a - 11, 7)); a = 0, o = i, 0 === s ? (f = 138, u = 3) : i === s ? (f = 6, u = 3) : (f = 7, u = 4) } } i(b); var N = !1; function C(t, e, r, i) { E(t, 0 + (i ? 1 : 0), 3), function (t, e, r, i) { A(t), v(t, r), v(t, ~r), n.arraySet(t.pending_buf, t.window, e, r, t.pending), t.pending += r }(t, e, r) } r._tr_init = function (t) { N || (function () { var t, e, r, n, i, f = new Array(16); for (r = 0, n = 0; n < 28; n++)for (d[n] = r, t = 0; t < 1 << o[n]; t++)c[r++] = n; for (c[r - 1] = n, i = 0, n = 0; n < 16; n++)for (b[n] = i, t = 0; t < 1 << s[n]; t++)h[i++] = n; for (i >>= 7; n < 30; n++)for (b[n] = i << 7, t = 0; t < 1 << s[n] - 7; t++)h[256 + i++] = n; for (e = 0; e <= 15; e++)f[e] = 0; for (t = 0; t <= 143;)u[2 * t + 1] = 8, t++, f[8]++; for (; t <= 255;)u[2 * t + 1] = 9, t++, f[9]++; for (; t <= 279;)u[2 * t + 1] = 7, t++, f[7]++; for (; t <= 287;)u[2 * t + 1] = 8, t++, f[8]++; for (x(u, 287, f), t = 0; t < 30; t++)l[2 * t + 1] = 5, l[2 * t] = S(t, 5); p = new _(u, o, 257, 286, 15), g = new _(l, s, 0, 30, 15), y = new _(new Array(0), a, 0, 19, 7) }(), N = !0), t.l_desc = new m(t.dyn_ltree, p), t.d_desc = new m(t.dyn_dtree, g), t.bl_desc = new m(t.bl_tree, y), t.bi_buf = 0, t.bi_valid = 0, L(t) }, r._tr_stored_block = C, r._tr_flush_block = function (t, e, r, n) { var i, o, s = 0; t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = function (t) { var e, r = 4093624447; for (e = 0; e <= 31; e++, r >>>= 1)if (1 & r && 0 !== t.dyn_ltree[2 * e]) return 0; if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1; for (e = 32; e < 256; e++)if (0 !== t.dyn_ltree[2 * e]) return 1; return 0 }(t)), R(t, t.l_desc), R(t, t.d_desc), s = function (t) { var e; for (O(t, t.dyn_ltree, t.l_desc.max_code), O(t, t.dyn_dtree, t.d_desc.max_code), R(t, t.bl_desc), e = 18; e >= 3 && 0 === t.bl_tree[2 * f[e] + 1]; e--); return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e }(t), i = t.opt_len + 3 + 7 >>> 3, (o = t.static_len + 3 + 7 >>> 3) <= i && (i = o)) : i = o = r + 5, r + 4 <= i && -1 !== e ? C(t, e, r, n) : 4 === t.strategy || o === i ? (E(t, 2 + (n ? 1 : 0), 3), I(t, u, l)) : (E(t, 4 + (n ? 1 : 0), 3), function (t, e, r, n) { var i; for (E(t, e - 257, 5), E(t, r - 1, 5), E(t, n - 4, 4), i = 0; i < n; i++)E(t, t.bl_tree[2 * f[i] + 1], 3); U(t, t.dyn_ltree, e - 1), U(t, t.dyn_dtree, r - 1) }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), I(t, t.dyn_ltree, t.dyn_dtree)), L(t), n && A(t) }, r._tr_tally = function (t, e, r) { return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & r, t.last_lit++, 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++, e--, t.dyn_ltree[2 * (c[r] + 256 + 1)]++, t.dyn_dtree[2 * w(e)]++), t.last_lit === t.lit_bufsize - 1 }, r._tr_align = function (t) { E(t, 2, 3), k(t, 256, u), function (t) { 16 === t.bi_valid ? (v(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8) }(t) } }, { "../utils/common": 17 }], 27: [function (t, e, r) { "use strict"; e.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } }, {}], 28: [function (t, e, r) { (function (t) { "use strict"; void 0 === t || !t.version || 0 === t.version.indexOf("v0.") || 0 === t.version.indexOf("v1.") && 0 !== t.version.indexOf("v1.8.") ? e.exports = { nextTick: function (e, r, n, i) { if ("function" != typeof e) throw new TypeError('"callback" argument must be a function'); var o, s, a = arguments.length; switch (a) { case 0: case 1: return t.nextTick(e); case 2: return t.nextTick((function () { e.call(null, r) })); case 3: return t.nextTick((function () { e.call(null, r, n) })); case 4: return t.nextTick((function () { e.call(null, r, n, i) })); default: for (o = new Array(a - 1), s = 0; s < o.length;)o[s++] = arguments[s]; return t.nextTick((function () { e.apply(null, o) })) } } } : e.exports = t }).call(this, t("_process")) }, { _process: 29 }], 29: [function (t, e, r) { var n, i, o = e.exports = {}; function s() { throw new Error("setTimeout has not been defined") } function a() { throw new Error("clearTimeout has not been defined") } function f(t) { if (n === setTimeout) return setTimeout(t, 0); if ((n === s || !n) && setTimeout) return n = setTimeout, setTimeout(t, 0); try { return n(t, 0) } catch (e) { try { return n.call(null, t, 0) } catch (e) { return n.call(this, t, 0) } } } !function () { try { n = "function" == typeof setTimeout ? setTimeout : s } catch (t) { n = s } try { i = "function" == typeof clearTimeout ? clearTimeout : a } catch (t) { i = a } }(); var u, l = [], h = !1, c = -1; function d() { h && u && (h = !1, u.length ? l = u.concat(l) : c = -1, l.length && p()) } function p() { if (!h) { var t = f(d); h = !0; for (var e = l.length; e;) { for (u = l, l = []; ++c < e;)u && u[c].run(); c = -1, e = l.length } u = null, h = !1, function (t) { if (i === clearTimeout) return clearTimeout(t); if ((i === a || !i) && clearTimeout) return i = clearTimeout, clearTimeout(t); try { i(t) } catch (e) { try { return i.call(null, t) } catch (e) { return i.call(this, t) } } }(t) } } function g(t, e) { this.fun = t, this.array = e } function y() { } o.nextTick = function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; l.push(new g(t, e)), 1 !== l.length || h || f(p) }, g.prototype.run = function () { this.fun.apply(null, this.array) }, o.title = "browser", o.browser = !0, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = y, o.addListener = y, o.once = y, o.off = y, o.removeListener = y, o.removeAllListeners = y, o.emit = y, o.prependListener = y, o.prependOnceListener = y, o.listeners = function (t) { return [] }, o.binding = function (t) { throw new Error("process.binding is not supported") }, o.cwd = function () { return "/" }, o.chdir = function (t) { throw new Error("process.chdir is not supported") }, o.umask = function () { return 0 } }, {}], 30: [function (t, e, r) { e.exports = t("./lib/_stream_duplex.js") }, { "./lib/_stream_duplex.js": 31 }], 31: [function (t, e, r) { "use strict"; var n = t("process-nextick-args"), i = Object.keys || function (t) { var e = []; for (var r in t) e.push(r); return e }; e.exports = h; var o = Object.create(t("core-util-is")); o.inherits = t("inherits"); var s = t("./_stream_readable"), a = t("./_stream_writable"); o.inherits(h, s); for (var f = i(a.prototype), u = 0; u < f.length; u++) { var l = f[u]; h.prototype[l] || (h.prototype[l] = a.prototype[l]) } function h(t) { if (!(this instanceof h)) return new h(t); s.call(this, t), a.call(this, t), t && !1 === t.readable && (this.readable = !1), t && !1 === t.writable && (this.writable = !1), this.allowHalfOpen = !0, t && !1 === t.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", c) } function c() { this.allowHalfOpen || this._writableState.ended || n.nextTick(d, this) } function d(t) { t.end() } Object.defineProperty(h.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), Object.defineProperty(h.prototype, "destroyed", { get: function () { return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed }, set: function (t) { void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t) } }), h.prototype._destroy = function (t, e) { this.push(null), this.end(), n.nextTick(e, t) } }, { "./_stream_readable": 33, "./_stream_writable": 35, "core-util-is": 10, inherits: 13, "process-nextick-args": 28 }], 32: [function (t, e, r) { "use strict"; e.exports = o; var n = t("./_stream_transform"), i = Object.create(t("core-util-is")); function o(t) { if (!(this instanceof o)) return new o(t); n.call(this, t) } i.inherits = t("inherits"), i.inherits(o, n), o.prototype._transform = function (t, e, r) { r(null, t) } }, { "./_stream_transform": 34, "core-util-is": 10, inherits: 13 }], 33: [function (t, e, n) { (function (r, n) { "use strict"; var i = t("process-nextick-args"); e.exports = m; var o, s = t("isarray"); m.ReadableState = _, t("events").EventEmitter; var a = function (t, e) { return t.listeners(e).length }, f = t("./internal/streams/stream"), u = t("safe-buffer").Buffer, l = n.Uint8Array || function () { }, h = Object.create(t("core-util-is")); h.inherits = t("inherits"); var c = t("util"), d = void 0; d = c && c.debuglog ? c.debuglog("stream") : function () { }; var p, g = t("./internal/streams/BufferList"), y = t("./internal/streams/destroy"); h.inherits(m, f); var b = ["error", "close", "destroy", "pause", "resume"]; function _(e, r) { e = e || {}; var n = r instanceof (o = o || t("./_stream_duplex")); this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode); var i = e.highWaterMark, s = e.readableHighWaterMark, a = this.objectMode ? 16 : 16384; this.highWaterMark = i || 0 === i ? i : n && (s || 0 === s) ? s : a, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new g, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (p || (p = t("string_decoder/").StringDecoder), this.decoder = new p(e.encoding), this.encoding = e.encoding) } function m(e) { if (o = o || t("./_stream_duplex"), !(this instanceof m)) return new m(e); this._readableState = new _(e, this), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), f.call(this) } function w(t, e, r, n, i) { var o, s = t._readableState; return null === e ? (s.reading = !1, function (t, e) { if (!e.ended) { if (e.decoder) { var r = e.decoder.end(); r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length) } e.ended = !0, S(t) } }(t, s)) : (i || (o = function (t, e) { var r, n; return n = e, u.isBuffer(n) || n instanceof l || "string" == typeof e || void 0 === e || t.objectMode || (r = new TypeError("Invalid non-string/buffer chunk")), r }(s, e)), o ? t.emit("error", o) : s.objectMode || e && e.length > 0 ? ("string" == typeof e || s.objectMode || Object.getPrototypeOf(e) === u.prototype || (e = function (t) { return u.from(t) }(e)), n ? s.endEmitted ? t.emit("error", new Error("stream.unshift() after end event")) : v(t, s, e, !0) : s.ended ? t.emit("error", new Error("stream.push() after EOF")) : (s.reading = !1, s.decoder && !r ? (e = s.decoder.write(e), s.objectMode || 0 !== e.length ? v(t, s, e, !1) : L(t, s)) : v(t, s, e, !1))) : n || (s.reading = !1)), function (t) { return !t.ended && (t.needReadable || t.length < t.highWaterMark || 0 === t.length) }(s) } function v(t, e, r, n) { e.flowing && 0 === e.length && !e.sync ? (t.emit("data", r), t.read(0)) : (e.length += e.objectMode ? 1 : r.length, n ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && S(t)), L(t, e) } Object.defineProperty(m.prototype, "destroyed", { get: function () { return void 0 !== this._readableState && this._readableState.destroyed }, set: function (t) { this._readableState && (this._readableState.destroyed = t) } }), m.prototype.destroy = y.destroy, m.prototype._undestroy = y.undestroy, m.prototype._destroy = function (t, e) { this.push(null), e(t) }, m.prototype.push = function (t, e) { var r, n = this._readableState; return n.objectMode ? r = !0 : "string" == typeof t && ((e = e || n.defaultEncoding) !== n.encoding && (t = u.from(t, e), e = ""), r = !0), w(this, t, e, !1, r) }, m.prototype.unshift = function (t) { return w(this, t, null, !0, !1) }, m.prototype.isPaused = function () { return !1 === this._readableState.flowing }, m.prototype.setEncoding = function (e) { return p || (p = t("string_decoder/").StringDecoder), this._readableState.decoder = new p(e), this._readableState.encoding = e, this }; var E = 8388608; function k(t, e) { return t <= 0 || 0 === e.length && e.ended ? 0 : e.objectMode ? 1 : t != t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = function (t) { return t >= E ? t = E : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t }(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = !0, 0)) } function S(t) { var e = t._readableState; e.needReadable = !1, e.emittedReadable || (d("emitReadable", e.flowing), e.emittedReadable = !0, e.sync ? i.nextTick(x, t) : x(t)) } function x(t) { d("emit readable"), t.emit("readable"), I(t) } function L(t, e) { e.readingMore || (e.readingMore = !0, i.nextTick(A, t, e)) } function A(t, e) { for (var r = e.length; !e.reading && !e.flowing && !e.ended && e.length < e.highWaterMark && (d("maybeReadMore read 0"), t.read(0), r !== e.length);)r = e.length; e.readingMore = !1 } function B(t) { d("readable nexttick read 0"), t.read(0) } function T(t, e) { e.reading || (d("resume read 0"), t.read(0)), e.resumeScheduled = !1, e.awaitDrain = 0, t.emit("resume"), I(t), e.flowing && !e.reading && t.read(0) } function I(t) { var e = t._readableState; for (d("flow", e.flowing); e.flowing && null !== t.read();); } function R(t, e) { return 0 === e.length ? null : (e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (r = e.decoder ? e.buffer.join("") : 1 === e.buffer.length ? e.buffer.head.data : e.buffer.concat(e.length), e.buffer.clear()) : r = function (t, e, r) { var n; return t < e.head.data.length ? (n = e.head.data.slice(0, t), e.head.data = e.head.data.slice(t)) : n = t === e.head.data.length ? e.shift() : r ? function (t, e) { var r = e.head, n = 1, i = r.data; for (t -= i.length; r = r.next;) { var o = r.data, s = t > o.length ? o.length : t; if (s === o.length ? i += o : i += o.slice(0, t), 0 == (t -= s)) { s === o.length ? (++n, r.next ? e.head = r.next : e.head = e.tail = null) : (e.head = r, r.data = o.slice(s)); break } ++n } return e.length -= n, i }(t, e) : function (t, e) { var r = u.allocUnsafe(t), n = e.head, i = 1; for (n.data.copy(r), t -= n.data.length; n = n.next;) { var o = n.data, s = t > o.length ? o.length : t; if (o.copy(r, r.length - t, 0, s), 0 == (t -= s)) { s === o.length ? (++i, n.next ? e.head = n.next : e.head = e.tail = null) : (e.head = n, n.data = o.slice(s)); break } ++i } return e.length -= i, r }(t, e), n }(t, e.buffer, e.decoder), r); var r } function O(t) { var e = t._readableState; if (e.length > 0) throw new Error('"endReadable()" called on non-empty stream'); e.endEmitted || (e.ended = !0, i.nextTick(U, e, t)) } function U(t, e) { t.endEmitted || 0 !== t.length || (t.endEmitted = !0, e.readable = !1, e.emit("end")) } function N(t, e) { for (var r = 0, n = t.length; r < n; r++)if (t[r] === e) return r; return -1 } m.prototype.read = function (t) { d("read", t), t = parseInt(t, 10); var e = this._readableState, r = t; if (0 !== t && (e.emittedReadable = !1), 0 === t && e.needReadable && (e.length >= e.highWaterMark || e.ended)) return d("read: emitReadable", e.length, e.ended), 0 === e.length && e.ended ? O(this) : S(this), null; if (0 === (t = k(t, e)) && e.ended) return 0 === e.length && O(this), null; var n, i = e.needReadable; return d("need readable", i), (0 === e.length || e.length - t < e.highWaterMark) && d("length less than watermark", i = !0), e.ended || e.reading ? d("reading or ended", i = !1) : i && (d("do read"), e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (t = k(r, e))), null === (n = t > 0 ? R(t, e) : null) ? (e.needReadable = !0, t = 0) : e.length -= t, 0 === e.length && (e.ended || (e.needReadable = !0), r !== t && e.ended && O(this)), null !== n && this.emit("data", n), n }, m.prototype._read = function (t) { this.emit("error", new Error("_read() is not implemented")) }, m.prototype.pipe = function (t, e) { var n = this, o = this._readableState; switch (o.pipesCount) { case 0: o.pipes = t; break; case 1: o.pipes = [o.pipes, t]; break; default: o.pipes.push(t) }o.pipesCount += 1, d("pipe count=%d opts=%j", o.pipesCount, e); var f = e && !1 === e.end || t === r.stdout || t === r.stderr ? _ : u; function u() { d("onend"), t.end() } o.endEmitted ? i.nextTick(f) : n.once("end", f), t.on("unpipe", (function e(r, i) { d("onunpipe"), r === n && i && !1 === i.hasUnpiped && (i.hasUnpiped = !0, d("cleanup"), t.removeListener("close", y), t.removeListener("finish", b), t.removeListener("drain", l), t.removeListener("error", g), t.removeListener("unpipe", e), n.removeListener("end", u), n.removeListener("end", _), n.removeListener("data", p), h = !0, !o.awaitDrain || t._writableState && !t._writableState.needDrain || l()) })); var l = function (t) { return function () { var e = t._readableState; d("pipeOnDrain", e.awaitDrain), e.awaitDrain && e.awaitDrain--, 0 === e.awaitDrain && a(t, "data") && (e.flowing = !0, I(t)) } }(n); t.on("drain", l); var h = !1, c = !1; function p(e) { d("ondata"), c = !1, !1 !== t.write(e) || c || ((1 === o.pipesCount && o.pipes === t || o.pipesCount > 1 && -1 !== N(o.pipes, t)) && !h && (d("false write response, pause", n._readableState.awaitDrain), n._readableState.awaitDrain++, c = !0), n.pause()) } function g(e) { d("onerror", e), _(), t.removeListener("error", g), 0 === a(t, "error") && t.emit("error", e) } function y() { t.removeListener("finish", b), _() } function b() { d("onfinish"), t.removeListener("close", y), _() } function _() { d("unpipe"), n.unpipe(t) } return n.on("data", p), function (t, e, r) { if ("function" == typeof t.prependListener) return t.prependListener(e, r); t._events && t._events.error ? s(t._events.error) ? t._events.error.unshift(r) : t._events.error = [r, t._events.error] : t.on(e, r) }(t, "error", g), t.once("close", y), t.once("finish", b), t.emit("pipe", n), o.flowing || (d("pipe resume"), n.resume()), t }, m.prototype.unpipe = function (t) { var e = this._readableState, r = { hasUnpiped: !1 }; if (0 === e.pipesCount) return this; if (1 === e.pipesCount) return t && t !== e.pipes || (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, r)), this; if (!t) { var n = e.pipes, i = e.pipesCount; e.pipes = null, e.pipesCount = 0, e.flowing = !1; for (var o = 0; o < i; o++)n[o].emit("unpipe", this, r); return this } var s = N(e.pipes, t); return -1 === s || (e.pipes.splice(s, 1), e.pipesCount -= 1, 1 === e.pipesCount && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r)), this }, m.prototype.on = function (t, e) { var r = f.prototype.on.call(this, t, e); if ("data" === t) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === t) { var n = this._readableState; n.endEmitted || n.readableListening || (n.readableListening = n.needReadable = !0, n.emittedReadable = !1, n.reading ? n.length && S(this) : i.nextTick(B, this)) } return r }, m.prototype.addListener = m.prototype.on, m.prototype.resume = function () { var t = this._readableState; return t.flowing || (d("resume"), t.flowing = !0, function (t, e) { e.resumeScheduled || (e.resumeScheduled = !0, i.nextTick(T, t, e)) }(this, t)), this }, m.prototype.pause = function () { return d("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (d("pause"), this._readableState.flowing = !1, this.emit("pause")), this }, m.prototype.wrap = function (t) { var e = this, r = this._readableState, n = !1; for (var i in t.on("end", (function () { if (d("wrapped end"), r.decoder && !r.ended) { var t = r.decoder.end(); t && t.length && e.push(t) } e.push(null) })), t.on("data", (function (i) { d("wrapped data"), r.decoder && (i = r.decoder.write(i)), r.objectMode && null == i || (r.objectMode || i && i.length) && (e.push(i) || (n = !0, t.pause())) })), t) void 0 === this[i] && "function" == typeof t[i] && (this[i] = function (e) { return function () { return t[e].apply(t, arguments) } }(i)); for (var o = 0; o < b.length; o++)t.on(b[o], this.emit.bind(this, b[o])); return this._read = function (e) { d("wrapped _read", e), n && (n = !1, t.resume()) }, this }, Object.defineProperty(m.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark } }), m._fromList = R }).call(this, t("_process"), void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "./_stream_duplex": 31, "./internal/streams/BufferList": 36, "./internal/streams/destroy": 37, "./internal/streams/stream": 38, _process: 29, "core-util-is": 10, events: 11, inherits: 13, isarray: 15, "process-nextick-args": 28, "safe-buffer": 39, "string_decoder/": 40, util: 6 }], 34: [function (t, e, r) { "use strict"; e.exports = s; var n = t("./_stream_duplex"), i = Object.create(t("core-util-is")); function o(t, e) { var r = this._transformState; r.transforming = !1; var n = r.writecb; if (!n) return this.emit("error", new Error("write callback called multiple times")); r.writechunk = null, r.writecb = null, null != e && this.push(e), n(t); var i = this._readableState; i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark) } function s(t) { if (!(this instanceof s)) return new s(t); n.call(this, t), this._transformState = { afterTransform: o.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" == typeof t.transform && (this._transform = t.transform), "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", a) } function a() { var t = this; "function" == typeof this._flush ? this._flush((function (e, r) { f(t, e, r) })) : f(this, null, null) } function f(t, e, r) { if (e) return t.emit("error", e); if (null != r && t.push(r), t._writableState.length) throw new Error("Calling transform done when ws.length != 0"); if (t._transformState.transforming) throw new Error("Calling transform done when still transforming"); return t.push(null) } i.inherits = t("inherits"), i.inherits(s, n), s.prototype.push = function (t, e) { return this._transformState.needTransform = !1, n.prototype.push.call(this, t, e) }, s.prototype._transform = function (t, e, r) { throw new Error("_transform() is not implemented") }, s.prototype._write = function (t, e, r) { var n = this._transformState; if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) { var i = this._readableState; (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark) } }, s.prototype._read = function (t) { var e = this._transformState; null !== e.writechunk && e.writecb && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0 }, s.prototype._destroy = function (t, e) { var r = this; n.prototype._destroy.call(this, t, (function (t) { e(t), r.emit("close") })) } }, { "./_stream_duplex": 31, "core-util-is": 10, inherits: 13 }], 35: [function (t, e, n) { (function (r, n, i) { "use strict"; var o = t("process-nextick-args"); function s(t) { var e = this; this.next = null, this.entry = null, this.finish = function () { !function (t, e, r) { var n = t.entry; for (t.entry = null; n;) { var i = n.callback; e.pendingcb--, i(undefined), n = n.next } e.corkedRequestsFree ? e.corkedRequestsFree.next = t : e.corkedRequestsFree = t }(e, t) } } e.exports = _; var a, f = !r.browser && ["v0.10", "v0.9."].indexOf(r.version.slice(0, 5)) > -1 ? i : o.nextTick; _.WritableState = b; var u = Object.create(t("core-util-is")); u.inherits = t("inherits"); var l, h = { deprecate: t("util-deprecate") }, c = t("./internal/streams/stream"), d = t("safe-buffer").Buffer, p = n.Uint8Array || function () { }, g = t("./internal/streams/destroy"); function y() { } function b(e, r) { a = a || t("./_stream_duplex"), e = e || {}; var n = r instanceof a; this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.writableObjectMode); var i = e.highWaterMark, u = e.writableHighWaterMark, l = this.objectMode ? 16 : 16384; this.highWaterMark = i || 0 === i ? i : n && (u || 0 === u) ? u : l, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var h = !1 === e.decodeStrings; this.decodeStrings = !h, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (t) { !function (t, e) { var r = t._writableState, n = r.sync, i = r.writecb; if (function (t) { t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0 }(r), e) !function (t, e, r, n, i) { --e.pendingcb, r ? (o.nextTick(i, n), o.nextTick(S, t, e), t._writableState.errorEmitted = !0, t.emit("error", n)) : (i(n), t._writableState.errorEmitted = !0, t.emit("error", n), S(t, e)) }(t, r, n, e, i); else { var s = E(r); s || r.corked || r.bufferProcessing || !r.bufferedRequest || v(t, r), n ? f(w, t, r, s, i) : w(t, r, s, i) } }(r, t) }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this) } function _(e) { if (a = a || t("./_stream_duplex"), !(l.call(_, this) || this instanceof a)) return new _(e); this._writableState = new b(e, this), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), c.call(this) } function m(t, e, r, n, i, o, s) { e.writelen = n, e.writecb = s, e.writing = !0, e.sync = !0, r ? t._writev(i, e.onwrite) : t._write(i, o, e.onwrite), e.sync = !1 } function w(t, e, r, n) { r || function (t, e) { 0 === e.length && e.needDrain && (e.needDrain = !1, t.emit("drain")) }(t, e), e.pendingcb--, n(), S(t, e) } function v(t, e) { e.bufferProcessing = !0; var r = e.bufferedRequest; if (t._writev && r && r.next) { var n = e.bufferedRequestCount, i = new Array(n), o = e.corkedRequestsFree; o.entry = r; for (var a = 0, f = !0; r;)i[a] = r, r.isBuf || (f = !1), r = r.next, a += 1; i.allBuffers = f, m(t, e, !0, e.length, i, "", o.finish), e.pendingcb++, e.lastBufferedRequest = null, o.next ? (e.corkedRequestsFree = o.next, o.next = null) : e.corkedRequestsFree = new s(e), e.bufferedRequestCount = 0 } else { for (; r;) { var u = r.chunk, l = r.encoding, h = r.callback; if (m(t, e, !1, e.objectMode ? 1 : u.length, u, l, h), r = r.next, e.bufferedRequestCount--, e.writing) break } null === r && (e.lastBufferedRequest = null) } e.bufferedRequest = r, e.bufferProcessing = !1 } function E(t) { return t.ending && 0 === t.length && null === t.bufferedRequest && !t.finished && !t.writing } function k(t, e) { t._final((function (r) { e.pendingcb--, r && t.emit("error", r), e.prefinished = !0, t.emit("prefinish"), S(t, e) })) } function S(t, e) { var r = E(e); return r && (function (t, e) { e.prefinished || e.finalCalled || ("function" == typeof t._final ? (e.pendingcb++, e.finalCalled = !0, o.nextTick(k, t, e)) : (e.prefinished = !0, t.emit("prefinish"))) }(t, e), 0 === e.pendingcb && (e.finished = !0, t.emit("finish"))), r } u.inherits(_, c), b.prototype.getBuffer = function () { for (var t = this.bufferedRequest, e = []; t;)e.push(t), t = t.next; return e }, function () { try { Object.defineProperty(b.prototype, "buffer", { get: h.deprecate((function () { return this.getBuffer() }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") }) } catch (t) { } }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (l = Function.prototype[Symbol.hasInstance], Object.defineProperty(_, Symbol.hasInstance, { value: function (t) { return !!l.call(this, t) || this === _ && t && t._writableState instanceof b } })) : l = function (t) { return t instanceof this }, _.prototype.pipe = function () { this.emit("error", new Error("Cannot pipe, not readable")) }, _.prototype.write = function (t, e, r) { var n, i = this._writableState, s = !1, a = !i.objectMode && (n = t, d.isBuffer(n) || n instanceof p); return a && !d.isBuffer(t) && (t = function (t) { return d.from(t) }(t)), "function" == typeof e && (r = e, e = null), a ? e = "buffer" : e || (e = i.defaultEncoding), "function" != typeof r && (r = y), i.ended ? function (t, e) { var r = new Error("write after end"); t.emit("error", r), o.nextTick(e, r) }(this, r) : (a || function (t, e, r, n) { var i = !0, s = !1; return null === r ? s = new TypeError("May not write null values to stream") : "string" == typeof r || void 0 === r || e.objectMode || (s = new TypeError("Invalid non-string/buffer chunk")), s && (t.emit("error", s), o.nextTick(n, s), i = !1), i }(this, i, t, r)) && (i.pendingcb++, s = function (t, e, r, n, i, o) { if (!r) { var s = function (t, e, r) { return t.objectMode || !1 === t.decodeStrings || "string" != typeof e || (e = d.from(e, r)), e }(e, n, i); n !== s && (r = !0, i = "buffer", n = s) } var a = e.objectMode ? 1 : n.length; e.length += a; var f = e.length < e.highWaterMark; if (f || (e.needDrain = !0), e.writing || e.corked) { var u = e.lastBufferedRequest; e.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o, next: null }, u ? u.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1 } else m(t, e, !1, a, n, i, o); return f }(this, i, a, t, e, r)), s }, _.prototype.cork = function () { this._writableState.corked++ }, _.prototype.uncork = function () { var t = this._writableState; t.corked && (t.corked--, t.writing || t.corked || t.finished || t.bufferProcessing || !t.bufferedRequest || v(this, t)) }, _.prototype.setDefaultEncoding = function (t) { if ("string" == typeof t && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t); return this._writableState.defaultEncoding = t, this }, Object.defineProperty(_.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), _.prototype._write = function (t, e, r) { r(new Error("_write() is not implemented")) }, _.prototype._writev = null, _.prototype.end = function (t, e, r) { var n = this._writableState; "function" == typeof t ? (r = t, t = null, e = null) : "function" == typeof e && (r = e, e = null), null != t && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || n.finished || function (t, e, r) { e.ending = !0, S(t, e), r && (e.finished ? o.nextTick(r) : t.once("finish", r)), e.ended = !0, t.writable = !1 }(this, n, r) }, Object.defineProperty(_.prototype, "destroyed", { get: function () { return void 0 !== this._writableState && this._writableState.destroyed }, set: function (t) { this._writableState && (this._writableState.destroyed = t) } }), _.prototype.destroy = g.destroy, _.prototype._undestroy = g.undestroy, _.prototype._destroy = function (t, e) { this.end(), e(t) } }).call(this, t("_process"), void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, t("timers").setImmediate) }, { "./_stream_duplex": 31, "./internal/streams/destroy": 37, "./internal/streams/stream": 38, _process: 29, "core-util-is": 10, inherits: 13, "process-nextick-args": 28, "safe-buffer": 39, timers: 46, "util-deprecate": 47 }], 36: [function (t, e, r) { "use strict"; var n = t("safe-buffer").Buffer, i = t("util"); e.exports = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.head = null, this.tail = null, this.length = 0 } return t.prototype.push = function (t) { var e = { data: t, next: null }; this.length > 0 ? this.tail.next = e : this.head = e, this.tail = e, ++this.length }, t.prototype.unshift = function (t) { var e = { data: t, next: this.head }; 0 === this.length && (this.tail = e), this.head = e, ++this.length }, t.prototype.shift = function () { if (0 !== this.length) { var t = this.head.data; return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t } }, t.prototype.clear = function () { this.head = this.tail = null, this.length = 0 }, t.prototype.join = function (t) { if (0 === this.length) return ""; for (var e = this.head, r = "" + e.data; e = e.next;)r += t + e.data; return r }, t.prototype.concat = function (t) { if (0 === this.length) return n.alloc(0); if (1 === this.length) return this.head.data; for (var e, r, i = n.allocUnsafe(t >>> 0), o = this.head, s = 0; o;)e = i, r = s, o.data.copy(e, r), s += o.data.length, o = o.next; return i }, t }(), i && i.inspect && i.inspect.custom && (e.exports.prototype[i.inspect.custom] = function () { var t = i.inspect({ length: this.length }); return this.constructor.name + " " + t }) }, { "safe-buffer": 39, util: 6 }], 37: [function (t, e, r) { "use strict"; var n = t("process-nextick-args"); function i(t, e) { t.emit("error", e) } e.exports = { destroy: function (t, e) { var r = this, o = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed; return o || s ? (e ? e(t) : !t || this._writableState && this._writableState.errorEmitted || n.nextTick(i, this, t), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, (function (t) { !e && t ? (n.nextTick(i, r, t), r._writableState && (r._writableState.errorEmitted = !0)) : e && e(t) })), this) }, undestroy: function () { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1) } } }, { "process-nextick-args": 28 }], 38: [function (t, e, r) { e.exports = t("events").EventEmitter }, { events: 11 }], 39: [function (t, e, r) { var n = t("buffer"), i = n.Buffer; function o(t, e) { for (var r in t) e[r] = t[r] } function s(t, e, r) { return i(t, e, r) } i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = n : (o(n, r), r.Buffer = s), o(i, s), s.from = function (t, e, r) { if ("number" == typeof t) throw new TypeError("Argument must not be a number"); return i(t, e, r) }, s.alloc = function (t, e, r) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); var n = i(t); return void 0 !== e ? "string" == typeof r ? n.fill(e, r) : n.fill(e) : n.fill(0), n }, s.allocUnsafe = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return i(t) }, s.allocUnsafeSlow = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return n.SlowBuffer(t) } }, { buffer: 9 }], 40: [function (t, e, r) { "use strict"; var n = t("safe-buffer").Buffer, i = n.isEncoding || function (t) { switch ((t = "" + t) && t.toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": case "raw": return !0; default: return !1 } }; function o(t) { var e; switch (this.encoding = function (t) { var e = function (t) { if (!t) return "utf8"; for (var e; ;)switch (t) { case "utf8": case "utf-8": return "utf8"; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return "utf16le"; case "latin1": case "binary": return "latin1"; case "base64": case "ascii": case "hex": return t; default: if (e) return; t = ("" + t).toLowerCase(), e = !0 } }(t); if ("string" != typeof e && (n.isEncoding === i || !i(t))) throw new Error("Unknown encoding: " + t); return e || t }(t), this.encoding) { case "utf16le": this.text = f, this.end = u, e = 4; break; case "utf8": this.fillLast = a, e = 4; break; case "base64": this.text = l, this.end = h, e = 3; break; default: return this.write = c, void (this.end = d) }this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(e) } function s(t) { return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2 } function a(t) { var e = this.lastTotal - this.lastNeed, r = function (t, e, r) { if (128 != (192 & e[0])) return t.lastNeed = 0, "�"; if (t.lastNeed > 1 && e.length > 1) { if (128 != (192 & e[1])) return t.lastNeed = 1, "�"; if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) return t.lastNeed = 2, "�" } }(this, t); return void 0 !== r ? r : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), void (this.lastNeed -= t.length)) } function f(t, e) { if ((t.length - e) % 2 == 0) { var r = t.toString("utf16le", e); if (r) { var n = r.charCodeAt(r.length - 1); if (n >= 55296 && n <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1) } return r } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1) } function u(t) { var e = t && t.length ? this.write(t) : ""; if (this.lastNeed) { var r = this.lastTotal - this.lastNeed; return e + this.lastChar.toString("utf16le", 0, r) } return e } function l(t, e) { var r = (t.length - e) % 3; return 0 === r ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 === r ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r)) } function h(t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e } function c(t) { return t.toString(this.encoding) } function d(t) { return t && t.length ? this.write(t) : "" } r.StringDecoder = o, o.prototype.write = function (t) { if (0 === t.length) return ""; var e, r; if (this.lastNeed) { if (void 0 === (e = this.fillLast(t))) return ""; r = this.lastNeed, this.lastNeed = 0 } else r = 0; return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "" }, o.prototype.end = function (t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + "�" : e }, o.prototype.text = function (t, e) { var r = function (t, e, r) { var n = e.length - 1; if (n < r) return 0; var i = s(e[n]); return i >= 0 ? (i > 0 && (t.lastNeed = i - 1), i) : --n < r || -2 === i ? 0 : (i = s(e[n])) >= 0 ? (i > 0 && (t.lastNeed = i - 2), i) : --n < r || -2 === i ? 0 : (i = s(e[n])) >= 0 ? (i > 0 && (2 === i ? i = 0 : t.lastNeed = i - 3), i) : 0 }(this, t, e); if (!this.lastNeed) return t.toString("utf8", e); this.lastTotal = r; var n = t.length - (r - this.lastNeed); return t.copy(this.lastChar, 0, n), t.toString("utf8", e, n) }, o.prototype.fillLast = function (t) { if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length } }, { "safe-buffer": 39 }], 41: [function (t, e, r) { e.exports = t("./readable").PassThrough }, { "./readable": 42 }], 42: [function (t, e, r) { (r = e.exports = t("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = t("./lib/_stream_writable.js"), r.Duplex = t("./lib/_stream_duplex.js"), r.Transform = t("./lib/_stream_transform.js"), r.PassThrough = t("./lib/_stream_passthrough.js") }, { "./lib/_stream_duplex.js": 31, "./lib/_stream_passthrough.js": 32, "./lib/_stream_readable.js": 33, "./lib/_stream_transform.js": 34, "./lib/_stream_writable.js": 35 }], 43: [function (t, e, r) { e.exports = t("./readable").Transform }, { "./readable": 42 }], 44: [function (t, e, r) { e.exports = t("./lib/_stream_writable.js") }, { "./lib/_stream_writable.js": 35 }], 45: [function (t, e, r) { e.exports = i; var n = t("events").EventEmitter; function i() { n.call(this) } t("inherits")(i, n), i.Readable = t("readable-stream/readable.js"), i.Writable = t("readable-stream/writable.js"), i.Duplex = t("readable-stream/duplex.js"), i.Transform = t("readable-stream/transform.js"), i.PassThrough = t("readable-stream/passthrough.js"), i.Stream = i, i.prototype.pipe = function (t, e) { var r = this; function i(e) { t.writable && !1 === t.write(e) && r.pause && r.pause() } function o() { r.readable && r.resume && r.resume() } r.on("data", i), t.on("drain", o), t._isStdio || e && !1 === e.end || (r.on("end", a), r.on("close", f)); var s = !1; function a() { s || (s = !0, t.end()) } function f() { s || (s = !0, "function" == typeof t.destroy && t.destroy()) } function u(t) { if (l(), 0 === n.listenerCount(this, "error")) throw t } function l() { r.removeListener("data", i), t.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", f), r.removeListener("error", u), t.removeListener("error", u), r.removeListener("end", l), r.removeListener("close", l), t.removeListener("close", l) } return r.on("error", u), t.on("error", u), r.on("end", l), r.on("close", l), t.on("close", l), t.emit("pipe", r), t } }, { events: 11, inherits: 13, "readable-stream/duplex.js": 30, "readable-stream/passthrough.js": 41, "readable-stream/readable.js": 42, "readable-stream/transform.js": 43, "readable-stream/writable.js": 44 }], 46: [function (t, e, r) { (function (e, n) { var i = t("process/browser.js").nextTick, o = Function.prototype.apply, s = Array.prototype.slice, a = {}, f = 0; function u(t, e) { this._id = t, this._clearFn = e } r.setTimeout = function () { return new u(o.call(setTimeout, window, arguments), clearTimeout) }, r.setInterval = function () { return new u(o.call(setInterval, window, arguments), clearInterval) }, r.clearTimeout = r.clearInterval = function (t) { t.close() }, u.prototype.unref = u.prototype.ref = function () { }, u.prototype.close = function () { this._clearFn.call(window, this._id) }, r.enroll = function (t, e) { clearTimeout(t._idleTimeoutId), t._idleTimeout = e }, r.unenroll = function (t) { clearTimeout(t._idleTimeoutId), t._idleTimeout = -1 }, r._unrefActive = r.active = function (t) { clearTimeout(t._idleTimeoutId); var e = t._idleTimeout; e >= 0 && (t._idleTimeoutId = setTimeout((function () { t._onTimeout && t._onTimeout() }), e)) }, r.setImmediate = "function" == typeof e ? e : function (t) { var e = f++, n = !(arguments.length < 2) && s.call(arguments, 1); return a[e] = !0, i((function () { a[e] && (n ? t.apply(null, n) : t.call(null), r.clearImmediate(e)) })), e }, r.clearImmediate = "function" == typeof n ? n : function (t) { delete a[t] } }).call(this, t("timers").setImmediate, t("timers").clearImmediate) }, { "process/browser.js": 29, timers: 46 }], 47: [function (t, e, n) { (function (t) { function r(e) { try { if (!t.localStorage) return !1 } catch (t) { return !1 } var r = t.localStorage[e]; return null != r && "true" === String(r).toLowerCase() } e.exports = function (t, e) { if (r("noDeprecation")) return t; var n = !1; return function () { if (!n) { if (r("throwDeprecation")) throw new Error(e); r("traceDeprecation") ? console.trace(e) : console.warn(e), n = !0 } return t.apply(this, arguments) } } }).call(this, void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, {}], 48: [function (t, e, r) { arguments[4][2][0].apply(r, arguments) }, { dup: 2 }], 49: [function (t, e, r) { arguments[4][3][0].apply(r, arguments) }, { dup: 3 }], 50: [function (t, e, r) { arguments[4][4][0].apply(r, arguments) }, { "./support/isBuffer": 49, _process: 29, dup: 4, inherits: 48 }], 51: [function (t, e, r) { n = t("zlib") }, { zlib: 8 }] }, {}, [51]), t.exports = n }, 742: (t, e) => { "use strict"; e.byteLength = function (t) { var e = f(t), r = e[0], n = e[1]; return 3 * (r + n) / 4 - n }, e.toByteArray = function (t) { var e, r, o = f(t), s = o[0], a = o[1], u = new i(function (t, e, r) { return 3 * (e + r) / 4 - r }(0, s, a)), l = 0, h = a > 0 ? s - 4 : s; for (r = 0; r < h; r += 4)e = n[t.charCodeAt(r)] << 18 | n[t.charCodeAt(r + 1)] << 12 | n[t.charCodeAt(r + 2)] << 6 | n[t.charCodeAt(r + 3)], u[l++] = e >> 16 & 255, u[l++] = e >> 8 & 255, u[l++] = 255 & e; return 2 === a && (e = n[t.charCodeAt(r)] << 2 | n[t.charCodeAt(r + 1)] >> 4, u[l++] = 255 & e), 1 === a && (e = n[t.charCodeAt(r)] << 10 | n[t.charCodeAt(r + 1)] << 4 | n[t.charCodeAt(r + 2)] >> 2, u[l++] = e >> 8 & 255, u[l++] = 255 & e), u }, e.fromByteArray = function (t) { for (var e, n = t.length, i = n % 3, o = [], s = 16383, a = 0, f = n - i; a < f; a += s)o.push(u(t, a, a + s > f ? f : a + s)); return 1 === i ? (e = t[n - 1], o.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === i && (e = (t[n - 2] << 8) + t[n - 1], o.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "=")), o.join("") }; for (var r = [], n = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, a = o.length; s < a; ++s)r[s] = o[s], n[o.charCodeAt(s)] = s; function f(t) { var e = t.length; if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var r = t.indexOf("="); return -1 === r && (r = e), [r, r === e ? 0 : 4 - r % 4] } function u(t, e, n) { for (var i, o, s = [], a = e; a < n; a += 3)i = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]), s.push(r[(o = i) >> 18 & 63] + r[o >> 12 & 63] + r[o >> 6 & 63] + r[63 & o]); return s.join("") } n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63 }, 764: (t, e, r) => { "use strict"; const n = r(742), i = r(645), o = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null; e.lW = f, e.h2 = 50; const s = 2147483647; function a(t) { if (t > s) throw new RangeError('The value "' + t + '" is invalid for option "size"'); const e = new Uint8Array(t); return Object.setPrototypeOf(e, f.prototype), e } function f(t, e, r) { if ("number" == typeof t) { if ("string" == typeof e) throw new TypeError('The "string" argument must be of type string. Received type number'); return h(t) } return u(t, e, r) } function u(t, e, r) { if ("string" == typeof t) return function (t, e) { if ("string" == typeof e && "" !== e || (e = "utf8"), !f.isEncoding(e)) throw new TypeError("Unknown encoding: " + e); const r = 0 | g(t, e); let n = a(r); const i = n.write(t, e); return i !== r && (n = n.slice(0, i)), n }(t, e); if (ArrayBuffer.isView(t)) return function (t) { if (V(t, Uint8Array)) { const e = new Uint8Array(t); return d(e.buffer, e.byteOffset, e.byteLength) } return c(t) }(t); if (null == t) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); if (V(t, ArrayBuffer) || t && V(t.buffer, ArrayBuffer)) return d(t, e, r); if ("undefined" != typeof SharedArrayBuffer && (V(t, SharedArrayBuffer) || t && V(t.buffer, SharedArrayBuffer))) return d(t, e, r); if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number'); const n = t.valueOf && t.valueOf(); if (null != n && n !== t) return f.from(n, e, r); const i = function (t) { if (f.isBuffer(t)) { const e = 0 | p(t.length), r = a(e); return 0 === r.length || t.copy(r, 0, 0, e), r } return void 0 !== t.length ? "number" != typeof t.length || J(t.length) ? a(0) : c(t) : "Buffer" === t.type && Array.isArray(t.data) ? c(t.data) : void 0 }(t); if (i) return i; if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return f.from(t[Symbol.toPrimitive]("string"), e, r); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t) } function l(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be of type number'); if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"') } function h(t) { return l(t), a(t < 0 ? 0 : 0 | p(t)) } function c(t) { const e = t.length < 0 ? 0 : 0 | p(t.length), r = a(e); for (let n = 0; n < e; n += 1)r[n] = 255 & t[n]; return r } function d(t, e, r) { if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds'); if (t.byteLength < e + (r || 0)) throw new RangeError('"length" is outside of buffer bounds'); let n; return n = void 0 === e && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, e) : new Uint8Array(t, e, r), Object.setPrototypeOf(n, f.prototype), n } function p(t) { if (t >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes"); return 0 | t } function g(t, e) { if (f.isBuffer(t)) return t.length; if (ArrayBuffer.isView(t) || V(t, ArrayBuffer)) return t.byteLength; if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t); const r = t.length, n = arguments.length > 2 && !0 === arguments[2]; if (!n && 0 === r) return 0; let i = !1; for (; ;)switch (e) { case "ascii": case "latin1": case "binary": return r; case "utf8": case "utf-8": return H(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * r; case "hex": return r >>> 1; case "base64": return G(t).length; default: if (i) return n ? -1 : H(t).length; e = ("" + e).toLowerCase(), i = !0 } } function y(t, e, r) { let n = !1; if ((void 0 === e || e < 0) && (e = 0), e > this.length) return ""; if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return ""; if ((r >>>= 0) <= (e >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return I(this, e, r); case "utf8": case "utf-8": return L(this, e, r); case "ascii": return B(this, e, r); case "latin1": case "binary": return T(this, e, r); case "base64": return x(this, e, r); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return R(this, e, r); default: if (n) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), n = !0 } } function b(t, e, r) { const n = t[e]; t[e] = t[r], t[r] = n } function _(t, e, r, n, i) { if (0 === t.length) return -1; if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), J(r = +r) && (r = i ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) { if (i) return -1; r = t.length - 1 } else if (r < 0) { if (!i) return -1; r = 0 } if ("string" == typeof e && (e = f.from(e, n)), f.isBuffer(e)) return 0 === e.length ? -1 : m(t, e, r, n, i); if ("number" == typeof e) return e &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : m(t, [e], r, n, i); throw new TypeError("val must be string, number or Buffer") } function m(t, e, r, n, i) { let o, s = 1, a = t.length, f = e.length; if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) { if (t.length < 2 || e.length < 2) return -1; s = 2, a /= 2, f /= 2, r /= 2 } function u(t, e) { return 1 === s ? t[e] : t.readUInt16BE(e * s) } if (i) { let n = -1; for (o = r; o < a; o++)if (u(t, o) === u(e, -1 === n ? 0 : o - n)) { if (-1 === n && (n = o), o - n + 1 === f) return n * s } else -1 !== n && (o -= o - n), n = -1 } else for (r + f > a && (r = a - f), o = r; o >= 0; o--) { let r = !0; for (let n = 0; n < f; n++)if (u(t, o + n) !== u(e, n)) { r = !1; break } if (r) return o } return -1 } function w(t, e, r, n) { r = Number(r) || 0; const i = t.length - r; n ? (n = Number(n)) > i && (n = i) : n = i; const o = e.length; let s; for (n > o / 2 && (n = o / 2), s = 0; s < n; ++s) { const n = parseInt(e.substr(2 * s, 2), 16); if (J(n)) return s; t[r + s] = n } return s } function v(t, e, r, n) { return $(H(e, t.length - r), t, r, n) } function E(t, e, r, n) { return $(function (t) { const e = []; for (let r = 0; r < t.length; ++r)e.push(255 & t.charCodeAt(r)); return e }(e), t, r, n) } function k(t, e, r, n) { return $(G(e), t, r, n) } function S(t, e, r, n) { return $(function (t, e) { let r, n, i; const o = []; for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)r = t.charCodeAt(s), n = r >> 8, i = r % 256, o.push(i), o.push(n); return o }(e, t.length - r), t, r, n) } function x(t, e, r) { return 0 === e && r === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(e, r)) } function L(t, e, r) { r = Math.min(t.length, r); const n = []; let i = e; for (; i < r;) { const e = t[i]; let o = null, s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1; if (i + s <= r) { let r, n, a, f; switch (s) { case 1: e < 128 && (o = e); break; case 2: r = t[i + 1], 128 == (192 & r) && (f = (31 & e) << 6 | 63 & r, f > 127 && (o = f)); break; case 3: r = t[i + 1], n = t[i + 2], 128 == (192 & r) && 128 == (192 & n) && (f = (15 & e) << 12 | (63 & r) << 6 | 63 & n, f > 2047 && (f < 55296 || f > 57343) && (o = f)); break; case 4: r = t[i + 1], n = t[i + 2], a = t[i + 3], 128 == (192 & r) && 128 == (192 & n) && 128 == (192 & a) && (f = (15 & e) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & a, f > 65535 && f < 1114112 && (o = f)) } } null === o ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), n.push(o), i += s } return function (t) { const e = t.length; if (e <= A) return String.fromCharCode.apply(String, t); let r = "", n = 0; for (; n < e;)r += String.fromCharCode.apply(String, t.slice(n, n += A)); return r }(n) } f.TYPED_ARRAY_SUPPORT = function () { try { const t = new Uint8Array(1), e = { foo: function () { return 42 } }; return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), 42 === t.foo() } catch (t) { return !1 } }(), f.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(f.prototype, "parent", { enumerable: !0, get: function () { if (f.isBuffer(this)) return this.buffer } }), Object.defineProperty(f.prototype, "offset", { enumerable: !0, get: function () { if (f.isBuffer(this)) return this.byteOffset } }), f.poolSize = 8192, f.from = function (t, e, r) { return u(t, e, r) }, Object.setPrototypeOf(f.prototype, Uint8Array.prototype), Object.setPrototypeOf(f, Uint8Array), f.alloc = function (t, e, r) { return function (t, e, r) { return l(t), t <= 0 ? a(t) : void 0 !== e ? "string" == typeof r ? a(t).fill(e, r) : a(t).fill(e) : a(t) }(t, e, r) }, f.allocUnsafe = function (t) { return h(t) }, f.allocUnsafeSlow = function (t) { return h(t) }, f.isBuffer = function (t) { return null != t && !0 === t._isBuffer && t !== f.prototype }, f.compare = function (t, e) { if (V(t, Uint8Array) && (t = f.from(t, t.offset, t.byteLength)), V(e, Uint8Array) && (e = f.from(e, e.offset, e.byteLength)), !f.isBuffer(t) || !f.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (t === e) return 0; let r = t.length, n = e.length; for (let i = 0, o = Math.min(r, n); i < o; ++i)if (t[i] !== e[i]) { r = t[i], n = e[i]; break } return r < n ? -1 : n < r ? 1 : 0 }, f.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, f.concat = function (t, e) { if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return f.alloc(0); let r; if (void 0 === e) for (e = 0, r = 0; r < t.length; ++r)e += t[r].length; const n = f.allocUnsafe(e); let i = 0; for (r = 0; r < t.length; ++r) { let e = t[r]; if (V(e, Uint8Array)) i + e.length > n.length ? (f.isBuffer(e) || (e = f.from(e)), e.copy(n, i)) : Uint8Array.prototype.set.call(n, e, i); else { if (!f.isBuffer(e)) throw new TypeError('"list" argument must be an Array of Buffers'); e.copy(n, i) } i += e.length } return n }, f.byteLength = g, f.prototype._isBuffer = !0, f.prototype.swap16 = function () { const t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (let e = 0; e < t; e += 2)b(this, e, e + 1); return this }, f.prototype.swap32 = function () { const t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (let e = 0; e < t; e += 4)b(this, e, e + 3), b(this, e + 1, e + 2); return this }, f.prototype.swap64 = function () { const t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (let e = 0; e < t; e += 8)b(this, e, e + 7), b(this, e + 1, e + 6), b(this, e + 2, e + 5), b(this, e + 3, e + 4); return this }, f.prototype.toString = function () { const t = this.length; return 0 === t ? "" : 0 === arguments.length ? L(this, 0, t) : y.apply(this, arguments) }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function (t) { if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === f.compare(this, t) }, f.prototype.inspect = function () { let t = ""; const r = e.h2; return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">" }, o && (f.prototype[o] = f.prototype.inspect), f.prototype.compare = function (t, e, r, n, i) { if (V(t, Uint8Array) && (t = f.from(t, t.offset, t.byteLength)), !f.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t); if (void 0 === e && (e = 0), void 0 === r && (r = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), e < 0 || r > t.length || n < 0 || i > this.length) throw new RangeError("out of range index"); if (n >= i && e >= r) return 0; if (n >= i) return -1; if (e >= r) return 1; if (this === t) return 0; let o = (i >>>= 0) - (n >>>= 0), s = (r >>>= 0) - (e >>>= 0); const a = Math.min(o, s), u = this.slice(n, i), l = t.slice(e, r); for (let t = 0; t < a; ++t)if (u[t] !== l[t]) { o = u[t], s = l[t]; break } return o < s ? -1 : s < o ? 1 : 0 }, f.prototype.includes = function (t, e, r) { return -1 !== this.indexOf(t, e, r) }, f.prototype.indexOf = function (t, e, r) { return _(this, t, e, r, !0) }, f.prototype.lastIndexOf = function (t, e, r) { return _(this, t, e, r, !1) }, f.prototype.write = function (t, e, r, n) { if (void 0 === e) n = "utf8", r = this.length, e = 0; else if (void 0 === r && "string" == typeof e) n = e, r = this.length, e = 0; else { if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); e >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0) } const i = this.length - e; if ((void 0 === r || r > i) && (r = i), t.length > 0 && (r < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); let o = !1; for (; ;)switch (n) { case "hex": return w(this, t, e, r); case "utf8": case "utf-8": return v(this, t, e, r); case "ascii": case "latin1": case "binary": return E(this, t, e, r); case "base64": return k(this, t, e, r); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return S(this, t, e, r); default: if (o) throw new TypeError("Unknown encoding: " + n); n = ("" + n).toLowerCase(), o = !0 } }, f.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; const A = 4096; function B(t, e, r) { let n = ""; r = Math.min(t.length, r); for (let i = e; i < r; ++i)n += String.fromCharCode(127 & t[i]); return n } function T(t, e, r) { let n = ""; r = Math.min(t.length, r); for (let i = e; i < r; ++i)n += String.fromCharCode(t[i]); return n } function I(t, e, r) { const n = t.length; (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n); let i = ""; for (let n = e; n < r; ++n)i += Y[t[n]]; return i } function R(t, e, r) { const n = t.slice(e, r); let i = ""; for (let t = 0; t < n.length - 1; t += 2)i += String.fromCharCode(n[t] + 256 * n[t + 1]); return i } function O(t, e, r) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + e > r) throw new RangeError("Trying to access beyond buffer length") } function U(t, e, r, n, i, o) { if (!f.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > i || e < o) throw new RangeError('"value" argument is out of bounds'); if (r + n > t.length) throw new RangeError("Index out of range") } function N(t, e, r, n, i) { Z(e, n, i, t, r, 7); let o = Number(e & BigInt(4294967295)); t[r++] = o, o >>= 8, t[r++] = o, o >>= 8, t[r++] = o, o >>= 8, t[r++] = o; let s = Number(e >> BigInt(32) & BigInt(4294967295)); return t[r++] = s, s >>= 8, t[r++] = s, s >>= 8, t[r++] = s, s >>= 8, t[r++] = s, r } function C(t, e, r, n, i) { Z(e, n, i, t, r, 7); let o = Number(e & BigInt(4294967295)); t[r + 7] = o, o >>= 8, t[r + 6] = o, o >>= 8, t[r + 5] = o, o >>= 8, t[r + 4] = o; let s = Number(e >> BigInt(32) & BigInt(4294967295)); return t[r + 3] = s, s >>= 8, t[r + 2] = s, s >>= 8, t[r + 1] = s, s >>= 8, t[r] = s, r + 8 } function M(t, e, r, n, i, o) { if (r + n > t.length) throw new RangeError("Index out of range"); if (r < 0) throw new RangeError("Index out of range") } function z(t, e, r, n, o) { return e = +e, r >>>= 0, o || M(t, 0, r, 4), i.write(t, e, r, n, 23, 4), r + 4 } function j(t, e, r, n, o) { return e = +e, r >>>= 0, o || M(t, 0, r, 8), i.write(t, e, r, n, 52, 8), r + 8 } f.prototype.slice = function (t, e) { const r = this.length; (t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), e < t && (e = t); const n = this.subarray(t, e); return Object.setPrototypeOf(n, f.prototype), n }, f.prototype.readUintLE = f.prototype.readUIntLE = function (t, e, r) { t >>>= 0, e >>>= 0, r || O(t, e, this.length); let n = this[t], i = 1, o = 0; for (; ++o < e && (i *= 256);)n += this[t + o] * i; return n }, f.prototype.readUintBE = f.prototype.readUIntBE = function (t, e, r) { t >>>= 0, e >>>= 0, r || O(t, e, this.length); let n = this[t + --e], i = 1; for (; e > 0 && (i *= 256);)n += this[t + --e] * i; return n }, f.prototype.readUint8 = f.prototype.readUInt8 = function (t, e) { return t >>>= 0, e || O(t, 1, this.length), this[t] }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function (t, e) { return t >>>= 0, e || O(t, 2, this.length), this[t] | this[t + 1] << 8 }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function (t, e) { return t >>>= 0, e || O(t, 2, this.length), this[t] << 8 | this[t + 1] }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function (t, e) { return t >>>= 0, e || O(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function (t, e) { return t >>>= 0, e || O(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, f.prototype.readBigUInt64LE = X((function (t) { q(t >>>= 0, "offset"); const e = this[t], r = this[t + 7]; void 0 !== e && void 0 !== r || W(t, this.length - 8); const n = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24, i = this[++t] + 256 * this[++t] + 65536 * this[++t] + r * 2 ** 24; return BigInt(n) + (BigInt(i) << BigInt(32)) })), f.prototype.readBigUInt64BE = X((function (t) { q(t >>>= 0, "offset"); const e = this[t], r = this[t + 7]; void 0 !== e && void 0 !== r || W(t, this.length - 8); const n = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t], i = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + r; return (BigInt(n) << BigInt(32)) + BigInt(i) })), f.prototype.readIntLE = function (t, e, r) { t >>>= 0, e >>>= 0, r || O(t, e, this.length); let n = this[t], i = 1, o = 0; for (; ++o < e && (i *= 256);)n += this[t + o] * i; return i *= 128, n >= i && (n -= Math.pow(2, 8 * e)), n }, f.prototype.readIntBE = function (t, e, r) { t >>>= 0, e >>>= 0, r || O(t, e, this.length); let n = e, i = 1, o = this[t + --n]; for (; n > 0 && (i *= 256);)o += this[t + --n] * i; return i *= 128, o >= i && (o -= Math.pow(2, 8 * e)), o }, f.prototype.readInt8 = function (t, e) { return t >>>= 0, e || O(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, f.prototype.readInt16LE = function (t, e) { t >>>= 0, e || O(t, 2, this.length); const r = this[t] | this[t + 1] << 8; return 32768 & r ? 4294901760 | r : r }, f.prototype.readInt16BE = function (t, e) { t >>>= 0, e || O(t, 2, this.length); const r = this[t + 1] | this[t] << 8; return 32768 & r ? 4294901760 | r : r }, f.prototype.readInt32LE = function (t, e) { return t >>>= 0, e || O(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, f.prototype.readInt32BE = function (t, e) { return t >>>= 0, e || O(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, f.prototype.readBigInt64LE = X((function (t) { q(t >>>= 0, "offset"); const e = this[t], r = this[t + 7]; void 0 !== e && void 0 !== r || W(t, this.length - 8); const n = this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (r << 24); return (BigInt(n) << BigInt(32)) + BigInt(e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24) })), f.prototype.readBigInt64BE = X((function (t) { q(t >>>= 0, "offset"); const e = this[t], r = this[t + 7]; void 0 !== e && void 0 !== r || W(t, this.length - 8); const n = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t]; return (BigInt(n) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + r) })), f.prototype.readFloatLE = function (t, e) { return t >>>= 0, e || O(t, 4, this.length), i.read(this, t, !0, 23, 4) }, f.prototype.readFloatBE = function (t, e) { return t >>>= 0, e || O(t, 4, this.length), i.read(this, t, !1, 23, 4) }, f.prototype.readDoubleLE = function (t, e) { return t >>>= 0, e || O(t, 8, this.length), i.read(this, t, !0, 52, 8) }, f.prototype.readDoubleBE = function (t, e) { return t >>>= 0, e || O(t, 8, this.length), i.read(this, t, !1, 52, 8) }, f.prototype.writeUintLE = f.prototype.writeUIntLE = function (t, e, r, n) { t = +t, e >>>= 0, r >>>= 0, n || U(this, t, e, r, Math.pow(2, 8 * r) - 1, 0); let i = 1, o = 0; for (this[e] = 255 & t; ++o < r && (i *= 256);)this[e + o] = t / i & 255; return e + r }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function (t, e, r, n) { t = +t, e >>>= 0, r >>>= 0, n || U(this, t, e, r, Math.pow(2, 8 * r) - 1, 0); let i = r - 1, o = 1; for (this[e + i] = 255 & t; --i >= 0 && (o *= 256);)this[e + i] = t / o & 255; return e + r }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 1, 255, 0), this[e] = 255 & t, e + 1 }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 2, 65535, 0), this[e] = 255 & t, this[e + 1] = t >>> 8, e + 2 }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 2, 65535, 0), this[e] = t >>> 8, this[e + 1] = 255 & t, e + 2 }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 4, 4294967295, 0), this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t, e + 4 }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 4, 4294967295, 0), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4 }, f.prototype.writeBigUInt64LE = X((function (t, e = 0) { return N(this, t, e, BigInt(0), BigInt("0xffffffffffffffff")) })), f.prototype.writeBigUInt64BE = X((function (t, e = 0) { return C(this, t, e, BigInt(0), BigInt("0xffffffffffffffff")) })), f.prototype.writeIntLE = function (t, e, r, n) { if (t = +t, e >>>= 0, !n) { const n = Math.pow(2, 8 * r - 1); U(this, t, e, r, n - 1, -n) } let i = 0, o = 1, s = 0; for (this[e] = 255 & t; ++i < r && (o *= 256);)t < 0 && 0 === s && 0 !== this[e + i - 1] && (s = 1), this[e + i] = (t / o >> 0) - s & 255; return e + r }, f.prototype.writeIntBE = function (t, e, r, n) { if (t = +t, e >>>= 0, !n) { const n = Math.pow(2, 8 * r - 1); U(this, t, e, r, n - 1, -n) } let i = r - 1, o = 1, s = 0; for (this[e + i] = 255 & t; --i >= 0 && (o *= 256);)t < 0 && 0 === s && 0 !== this[e + i + 1] && (s = 1), this[e + i] = (t / o >> 0) - s & 255; return e + r }, f.prototype.writeInt8 = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1 }, f.prototype.writeInt16LE = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 2, 32767, -32768), this[e] = 255 & t, this[e + 1] = t >>> 8, e + 2 }, f.prototype.writeInt16BE = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 2, 32767, -32768), this[e] = t >>> 8, this[e + 1] = 255 & t, e + 2 }, f.prototype.writeInt32LE = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 4, 2147483647, -2147483648), this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24, e + 4 }, f.prototype.writeInt32BE = function (t, e, r) { return t = +t, e >>>= 0, r || U(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4 }, f.prototype.writeBigInt64LE = X((function (t, e = 0) { return N(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) })), f.prototype.writeBigInt64BE = X((function (t, e = 0) { return C(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) })), f.prototype.writeFloatLE = function (t, e, r) { return z(this, t, e, !0, r) }, f.prototype.writeFloatBE = function (t, e, r) { return z(this, t, e, !1, r) }, f.prototype.writeDoubleLE = function (t, e, r) { return j(this, t, e, !0, r) }, f.prototype.writeDoubleBE = function (t, e, r) { return j(this, t, e, !1, r) }, f.prototype.copy = function (t, e, r, n) { if (!f.isBuffer(t)) throw new TypeError("argument should be a Buffer"); if (r || (r = 0), n || 0 === n || (n = this.length), e >= t.length && (e = t.length), e || (e = 0), n > 0 && n < r && (n = r), n === r) return 0; if (0 === t.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (r < 0 || r >= this.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("sourceEnd out of bounds"); n > this.length && (n = this.length), t.length - e < n - r && (n = t.length - e + r); const i = n - r; return this === t && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e, r, n) : Uint8Array.prototype.set.call(t, this.subarray(r, n), e), i }, f.prototype.fill = function (t, e, r, n) { if ("string" == typeof t) { if ("string" == typeof e ? (n = e, e = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string"); if ("string" == typeof n && !f.isEncoding(n)) throw new TypeError("Unknown encoding: " + n); if (1 === t.length) { const e = t.charCodeAt(0); ("utf8" === n && e < 128 || "latin1" === n) && (t = e) } } else "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t)); if (e < 0 || this.length < e || this.length < r) throw new RangeError("Out of range index"); if (r <= e) return this; let i; if (e >>>= 0, r = void 0 === r ? this.length : r >>> 0, t || (t = 0), "number" == typeof t) for (i = e; i < r; ++i)this[i] = t; else { const o = f.isBuffer(t) ? t : f.from(t, n), s = o.length; if (0 === s) throw new TypeError('The value "' + t + '" is invalid for argument "value"'); for (i = 0; i < r - e; ++i)this[i + e] = o[i % s] } return this }; const D = {}; function F(t, e, r) { D[t] = class extends r { constructor() { super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${t}]`, this.stack, delete this.name } get code() { return t } set code(t) { Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: t, writable: !0 }) } toString() { return `${this.name} [${t}]: ${this.message}` } } } function P(t) { let e = "", r = t.length; const n = "-" === t[0] ? 1 : 0; for (; r >= n + 4; r -= 3)e = `_${t.slice(r - 3, r)}${e}`; return `${t.slice(0, r)}${e}` } function Z(t, e, r, n, i, o) { if (t > r || t < e) { const n = "bigint" == typeof e ? "n" : ""; let i; throw i = o > 3 ? 0 === e || e === BigInt(0) ? `>= 0${n} and < 2${n} ** ${8 * (o + 1)}${n}` : `>= -(2${n} ** ${8 * (o + 1) - 1}${n}) and < 2 ** ${8 * (o + 1) - 1}${n}` : `>= ${e}${n} and <= ${r}${n}`, new D.ERR_OUT_OF_RANGE("value", i, t) } !function (t, e, r) { q(e, "offset"), void 0 !== t[e] && void 0 !== t[e + r] || W(e, t.length - (r + 1)) }(n, i, o) } function q(t, e) { if ("number" != typeof t) throw new D.ERR_INVALID_ARG_TYPE(e, "number", t) } function W(t, e, r) { if (Math.floor(t) !== t) throw q(t, r), new D.ERR_OUT_OF_RANGE(r || "offset", "an integer", t); if (e < 0) throw new D.ERR_BUFFER_OUT_OF_BOUNDS; throw new D.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t) } F("ERR_BUFFER_OUT_OF_BOUNDS", (function (t) { return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds" }), RangeError), F("ERR_INVALID_ARG_TYPE", (function (t, e) { return `The "${t}" argument must be of type number. Received type ${typeof e}` }), TypeError), F("ERR_OUT_OF_RANGE", (function (t, e, r) { let n = `The value of "${t}" is out of range.`, i = r; return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = P(String(r)) : "bigint" == typeof r && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = P(i)), i += "n"), n += ` It must be ${e}. Received ${i}`, n }), RangeError); const K = /[^+/0-9A-Za-z-_]/g; function H(t, e) { let r; e = e || 1 / 0; const n = t.length; let i = null; const o = []; for (let s = 0; s < n; ++s) { if (r = t.charCodeAt(s), r > 55295 && r < 57344) { if (!i) { if (r > 56319) { (e -= 3) > -1 && o.push(239, 191, 189); continue } if (s + 1 === n) { (e -= 3) > -1 && o.push(239, 191, 189); continue } i = r; continue } if (r < 56320) { (e -= 3) > -1 && o.push(239, 191, 189), i = r; continue } r = 65536 + (i - 55296 << 10 | r - 56320) } else i && (e -= 3) > -1 && o.push(239, 191, 189); if (i = null, r < 128) { if ((e -= 1) < 0) break; o.push(r) } else if (r < 2048) { if ((e -= 2) < 0) break; o.push(r >> 6 | 192, 63 & r | 128) } else if (r < 65536) { if ((e -= 3) < 0) break; o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128) } else { if (!(r < 1114112)) throw new Error("Invalid code point"); if ((e -= 4) < 0) break; o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128) } } return o } function G(t) { return n.toByteArray(function (t) { if ((t = (t = t.split("=")[0]).trim().replace(K, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function $(t, e, r, n) { let i; for (i = 0; i < n && !(i + r >= e.length || i >= t.length); ++i)e[i + r] = t[i]; return i } function V(t, e) { return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name } function J(t) { return t != t } const Y = function () { const t = "0123456789abcdef", e = new Array(256); for (let r = 0; r < 16; ++r) { const n = 16 * r; for (let i = 0; i < 16; ++i)e[n + i] = t[r] + t[i] } return e }(); function X(t) { return "undefined" == typeof BigInt ? Q : t } function Q() { throw new Error("BigInt not supported") } }, 645: (t, e) => { e.read = function (t, e, r, n, i) { var o, s, a = 8 * i - n - 1, f = (1 << a) - 1, u = f >> 1, l = -7, h = r ? i - 1 : 0, c = r ? -1 : 1, d = t[e + h]; for (h += c, o = d & (1 << -l) - 1, d >>= -l, l += a; l > 0; o = 256 * o + t[e + h], h += c, l -= 8); for (s = o & (1 << -l) - 1, o >>= -l, l += n; l > 0; s = 256 * s + t[e + h], h += c, l -= 8); if (0 === o) o = 1 - u; else { if (o === f) return s ? NaN : 1 / 0 * (d ? -1 : 1); s += Math.pow(2, n), o -= u } return (d ? -1 : 1) * s * Math.pow(2, o - n) }, e.write = function (t, e, r, n, i, o) { var s, a, f, u = 8 * o - i - 1, l = (1 << u) - 1, h = l >> 1, c = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : o - 1, p = n ? 1 : -1, g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = l) : (s = Math.floor(Math.log(e) / Math.LN2), e * (f = Math.pow(2, -s)) < 1 && (s--, f *= 2), (e += s + h >= 1 ? c / f : c * Math.pow(2, 1 - h)) * f >= 2 && (s++, f /= 2), s + h >= l ? (a = 0, s = l) : s + h >= 1 ? (a = (e * f - 1) * Math.pow(2, i), s += h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; t[r + d] = 255 & a, d += p, a /= 256, i -= 8); for (s = s << i | a, u += i; u > 0; t[r + d] = 255 & s, d += p, s /= 256, u -= 8); t[r + d - p] |= 128 * g } } }, e = {}; function r(n) { var i = e[n]; if (void 0 !== i) return i.exports; var o = e[n] = { exports: {} }; return t[n](o, o.exports, r), o.exports } r.d = (t, e) => { for (var n in e) r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: e[n] }) }, r.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (t) { if ("object" == typeof window) return window } }(), r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e); var n = {}; (() => { "use strict"; r.d(n, { default: () => l }); const t = { PKT_SPEC: { 49: { 65: { type: "string", key: "symbol", len: 20 }, 66: { type: "uint8", key: "precision", len: 1 }, 67: { type: "float", key: "ltp", len: 8, fmt: function (t, e) { return i(t, e) } }, 68: { type: "float", key: "open", len: 8, fmt: function (t, e) { return i(t, e) } }, 69: { type: "float", key: "high", len: 8, fmt: function (t, e) { return i(t, e) } }, 70: { type: "float", key: "low", len: 8, fmt: function (t, e) { return i(t, e) } }, 71: { type: "float", key: "close", len: 8, fmt: function (t, e) { return i(t, e) } }, 72: { type: "float", key: "chng", len: 8, fmt: function (t, e) { return i(t, e) } }, 73: { type: "float", key: "chngPer", len: 8, fmt: function (t, e) { return i(t, 2) } }, 74: { type: "float", key: "atp", len: 8, fmt: function (t, e) { return i(t, e) } }, 75: { type: "float", key: "yHigh", len: 8, fmt: function (t, e) { return i(t, e) } }, 76: { type: "float", key: "yLow", len: 8, fmt: function (t, e) { return i(t, e) } }, 77: { type: "int32", key: "ltq", len: 4, fmt: function (t, e) { return i(t, 0) } }, 78: { type: "int32", key: "vol", len: 4, fmt: function (t, e) { return i(t, 0) } }, 79: { type: "float", key: "ttv", len: 8, fmt: function (t, e) { return i(t, e) } }, 80: { type: "float", key: "ucl", len: 8, fmt: function (t, e) { return i(t, e) } }, 81: { type: "float", key: "lcl", len: 8, fmt: function (t, e) { return i(t, e) } }, 82: { type: "int32", key: "OI", len: 4, fmt: function (t, e) { return i(t, 0) } }, 83: { type: "float", key: "OIChngPer", len: 8, fmt: function (t, e) { return i(t, 2) } }, 84: { type: "int32", key: "ltt", len: 4, fmt: function (t) { return o(t) } } }, 50: { 65: { type: "string", key: "symbol", len: 20 }, 66: { type: "uint8", key: "precision", len: 1 }, 85: { type: "int32", key: "totBuyQty", len: 4, fmt: function (t, e) { return i(t, 0) } }, 86: { type: "int32", key: "totSellQty", len: 4, fmt: function (t, e) { return i(t, 0) } }, 87: { type: "float", key: "price", len: 8, fmt: function (t, e) { return i(t, e) } }, 88: { type: "int32", key: "qty", len: 4, fmt: function (t, e) { return i(t, 0) } }, 89: { type: "int32", key: "no", len: 4, fmt: function (t, e) { return i(t, 0) } }, 90: { type: "float", key: "price", len: 8, fmt: function (t, e) { return i(t, e) } }, 91: { type: "int32", key: "qty", len: 4, fmt: function (t, e) { return i(t, 0) } }, 92: { type: "int32", key: "no", len: 4, fmt: function (t, e) { return i(t, 0) } }, 93: { type: "uint8", key: "nDepth", len: 1 } } }, BID_ASK_OBJ_LEN: 3 }; let e = "en-IN"; const i = (t, r = 2) => Number(parseFloat(t).toFixed(r)).toLocaleString(e, { minimumFractionDigits: r }), o = function (t) { if (!t) return t; t *= 1e3; let e = new Date(t).getDate(), r = new Date(t).getMonth(), n = new Date(t).getFullYear(), i = new Date(t).toLocaleTimeString(); return e < 10 && (e = "0" + e), e + " " + ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sep", "Oct", "Nov", "Dec"][r] + " " + n + ", " + i }; class s { constructor() { this.retryCount = 0, this.websocket = null, this.reconnectTimerFunc = null } openConnection = t => { if (!l.streamingURL) throw "Invalid streaming URL"; this.websocket = new WebSocket(l.streamingURL), l.binary && (this.websocket.binaryType = "arraybuffer"), this.websocket.addEventListener("open", this.onOpen), this.websocket.addEventListener("close", this.onClose), this.websocket.addEventListener("message", this.onMessage), this.websocket.addEventListener("error", this.onError), t && t() }; isConnected = () => this.websocket && (this.websocket.readyState === WebSocket.OPEN || this.websocket.readyState === WebSocket.CONNECTING); sendReq = t => { this.websocket && this.websocket.readyState === WebSocket.OPEN && this.websocket.send(JSON.stringify(t) + "\n") }; removeCallbacks = () => { this.websocket.removeEventListener("open", this.onOpen), this.websocket.removeEventListener("close", this.onClose), this.websocket.removeEventListener("message", this.onMessage), this.websocket.removeEventListener("error", this.onError) }; stop = () => { this.websocket && (console.log("Streaming stopping"), this.websocket.close()) }; reconnect = () => { this.isConnected() || (this.retryCount < l.websocketRetryCount ? (this.removeCallbacks(), this.retryCount++, this.reconnectTimerFunc && clearTimeout(this.reconnectTimerFunc), this.reconnectTimerFunc = setTimeout(function () { console.log("Streaming trying to reconnect attempt", this.retryCount), this.openConnection((() => { this.reconnect() })) }.bind(this), l.websocketRetryInternal)) : (console.log("Streaming trying to reconnect attempt limit reached", this.retryCount), l.onWebSocketError("Streaming trying to reconnect attempt limit reached"))) }; onOpen = t => { console.log("Streaming onOpen connected"), this.retryCount = 0, l.subscribeAll() }; onClose = t => { console.log("Streaming onClose ", t), l.onWebSocketClose(), this.removeCallbacks() }; onMessage = t => { l.onMessageRecv(t.data) }; onError = t => { console.log("Streaming onError ", t), l.onWebSocketError(t) } } var a = r(764).lW, f = r(301); class u { constructor(t) { this.cb = t } static #t = { 49: "quote", 50: "quote2" }; static #e = ""; static #r = ""; ab2str = (t, e, r) => String.fromCharCode.apply(null, new Uint8Array(t, e, r)).replace(/\0/g, ""); print = (t, e, r) => { let n = new Uint8Array(t, e, r); console.log(n) }; typedArrayToBuffer = t => t.buffer.slice(t.byteOffset, t.byteLength + t.byteOffset); process = t => { u.#e = l.pktInfo.PKT_SPEC, u.#r = l.pktInfo.BID_ASK_OBJ_LEN; let e = new DataView(t).getUint8(4, !0); 10 == e ? this.#n(t.slice(5)) : 0 == e && this.#i(t.slice(5)) }; #n = t => { var e = new a(t); f.inflate(e, ((t, e) => { t ? console.error("Decompression Error") : this.#i(e.buffer) })) }; #i = t => { for (let e = 0; e < t.byteLength;) { let r = this.#o(t.slice(e)); if (r <= 0) { console.error("Packet Length is wrong exiting the loop" + r); break } e += r } }; #s = (t, e, r, n) => { let i = {}, o = 2; for (let s = 3; s < e;) { let e = r.getUint8(s, !0); s += 1; let a = t[e]; if (void 0 === a) return console.error("Unknown Pkt spec breaking " + e), null; if ("string" === a.type) i[a.key] = [a, this.ab2str(n, s, a.len)]; else if ("float" === a.type) { let t = r.getFloat64(s, !0); i[a.key] = [a, t] } else if ("int32" === a.type) { let t = r.getInt32(s, !0); i[a.key] = [a, t] } else if ("uint8" === a.type) { let t = r.getUint8(s, !0); "precision" == a.key ? o = t : i[a.key] = [a, t] } s += a.len } let s = {}; for (var a in i) if (i.hasOwnProperty(a)) { let [t, e] = i[a]; s[t.key] = t.fmt ? t.fmt(e, o) : e } return s }; #a = (t, e, r, n) => { let i = 2, o = 0, s = [], a = [], f = null, l = {}, h = {}; for (let c = 3; c < e;) { let e = r.getUint8(c, !0); c += 1; let d = t[e]; if (void 0 === d) return console.error("Unknown Pkt spec breaking " + e), null; if ("string" === d.type) h[d.key] = [d, this.ab2str(n, c, d.len)]; else if ("float" === d.type) { let t = r.getFloat64(c, !0); f ? l[d.key] = d.fmt ? d.fmt(t, i) : t : h[d.key] = [d, t] } else if ("int32" === d.type) { let t = r.getInt32(c, !0); f ? l[d.key] = d.fmt ? d.fmt(t, i) : t : h[d.key] = [d, t] } else if ("uint8" === d.type) { let t = r.getUint8(c, !0); "nDepth" === d.key ? (o = t, f = s) : "precision" == d.key ? i = t : h[d.key] = [d, t] } c += d.len, f && (Object.keys(l).length == u.#r && (f.push(l), l = {}), o == f.length && (f = a)) } let c = {}; for (var d in h) if (h.hasOwnProperty(d)) { let [t, e] = h[d]; c[t.key] = t.fmt ? t.fmt(e, i) : e } return c.bid = s, c.ask = a, c }; #o = t => { var e = new DataView(t); let r = e.getUint16(0, !0), n = e.getUint8(2, 0), i = u.#e[n]; if (void 0 === i) return console.error("Unknown PktType " + n), r; let o = u.#t[n], s = null; if (o === l.LEVEL_1 ? s = this.#s(i, r, e, t) : o === l.LEVEL_2 && (s = this.#a(i, r, e, t)), !s) return r; let a = {}; a.streaming_type = o, a.data = s; let f = {}; return f.response = a, this.cb(f), r } } const l = new class { constructor() { this.session = null, this.streamingURL = null, this.binary = !1, this.pktInfo = { PKT_SPEC: t.PKT_SPEC, BID_ASK_OBJ_LEN: t.BID_ASK_OBJ_LEN }, this.websocketRetryCount = 100, this.websocketRetryInternal = 5e3, this.disconnectedCB = void 0, this.setInitialState(), this.websocketInterface = new s(this), this.isStopped = !1, this.LEVEL_1 = "quote", this.LEVEL_2 = "quote2", this.SUBSCRIBE = "subscribe", this.UNSUBSCRIBE = "unsubscribe", this.ALERTS = "alerts" } setInitialState() { this.referenceMap = {}, this.l1SubscribersSym = {}, this.l2SubscribersSym = {}, this.l1SymSubscribers = {}, this.l2SymSubscribers = {}, this.alertSubscribers = new Set } setSession = t => { this.session = t || null }; setStreamingURL = t => { this.streamingURL = t || null }; setBinary = t => { this.binary = t || !1 }; setRegionForCommaSeparation = t => { (t => { e = t })(t) }; setPacketInfo = e => { e && (this.pktInfo.PKT_SPEC = e.PKT_SPEC ? e.PKT_SPEC : t.PKT_SPEC, this.pktInfo.BID_ASK_OBJ_LEN = e.BID_ASK_OBJ_LEN ? e.BID_ASK_OBJ_LEN : t.BID_ASK_OBJ_LEN) }; setRetryCount = t => { this.websocketRetryCount = t || null }; setRetryInternal = t => { this.websocketRetryInternal = t || null }; setDisconnectedCB = t => { t && "function" == typeof t && (this.disconnectedCB = t) }; start = () => { if (!this.streamingURL) throw "Invalid session/Invalid streaming URL"; this.websocketInterface.isConnected() || this.websocketInterface.openConnection(), this.isStopped = !1 }; stop = () => { this.websocketInterface.stop(), this.setInitialState(), this.isStopped = !0 }; onMessageRecv = t => { this.binary ? new u(this.onMesageJSONResp).process(t) : this.onMesageJSONRecv(t) }; onMesageJSONRecv = t => { this.onMesageJSONResp(JSON.parse(t)) }; onMesageJSONResp = t => { if ((t = t.response).streaming_type == this.LEVEL_1) { let e = t.data.symbol, r = this.l1SymSubscribers[e]; if (!r) return; r.forEach((e => { let r = !1, n = this.referenceMap[e].keys; if (n && n.length) { for (var i = 0; i < n.length; i++)if (t.data && t.data.hasOwnProperty(n[i])) { r = !0; break } } else r = !0; r && this.referenceMap[e].cb(t) })) } if (t.streaming_type == this.LEVEL_2) { let e = t.data.symbol, r = this.l2SymSubscribers[e]; if (!r) return; r.forEach((e => { this.referenceMap[e](t) })) } else t.streaming_type == this.ALERTS && this.alertSubscribers.forEach((e => { this.referenceMap[e](t.data) })) }; subscribeAlerts = t => { this.alertSubscribers.add(t.compName), this.referenceMap[t.compName] = t.cb }; subscribeLevel1Syms = (t, e) => { this.subscribeLevel1(t, e.map((t => t.streamSym))) }; subscribeLevel2Syms = (t, e) => { this.subscribeLevel2(t, e.map((t => t.streamSym))) }; subscribeLevel1 = (t, e) => { let { compName: r, cb: n, forceSubscribe: i, keys: o } = t, s = this.unsubscribeLevel1(r, !0) || [], a = []; for (let t in e) { let n = e[t]; this.l1SymSubscribers[n] || a.push({ symbol: n }); let i = this.l1SymSubscribers[n] || new Set; i.add(r), this.l1SymSubscribers[n] = i } if (e.length > 0 && (this.l1SubscribersSym[r] = e), i) { let t = []; for (let r in e) t.push({ symbol: e[r] }); this.fireLevel1(t, s) } else this.fireLevel1(a, s); this.referenceMap[r] = { cb: n, keys: o } }; subscribeLevel2 = (t, e) => { let { compName: r, cb: n, forceSubscribe: i } = t, o = this.unsubscribeLevel2(r, !0) || [], s = []; for (let t in e) { let n = e[t]; this.l2SymSubscribers[n] || s.push({ symbol: n }); let i = this.l2SymSubscribers[n] || new Set; i.add(r), this.l2SymSubscribers[n] = i } if (e.length > 0 && (this.l2SubscribersSym[r] = e), i) { let t = []; for (let r in e) t.push({ symbol: e[r] }); this.fireLevel2(t, o) } else this.fireLevel2(s, o); this.referenceMap[r] = n }; unsubscribeAlert = t => { this.alertSubscribers.delete(t), delete this.referenceMap[t] }; unsubscribe = t => { this.unsubscribeAlert(t.compName), this.unsubscribeLevel1(t.compName), this.unsubscribeLevel2(t.compName) }; unsubscribeLevel1 = (t, e = !1) => { let r = []; for (let e in this.l1SubscribersSym[t]) { let n = this.l1SubscribersSym[t][e]; this.l1SymSubscribers[n] && (this.l1SymSubscribers[n].delete(t), 0 === this.l1SymSubscribers[n].size && (r.push({ symbol: n }), delete this.l1SymSubscribers[n])) } if (delete this.l1SubscribersSym[t], delete this.referenceMap[t], e) return r; r.length > 0 && this.fireLevel1([], r) }; unsubscribeLevel2 = (t, e = !1) => { let r = []; for (let e in this.l2SubscribersSym[t]) { let n = this.l2SubscribersSym[t][e]; this.l2SymSubscribers[n] && (this.l2SymSubscribers[n].delete(t), 0 === this.l2SymSubscribers[n].size && (r.push({ symbol: n }), delete this.l2SymSubscribers[n])) } if (delete this.l2SubscribersSym[t], delete this.referenceMap[t], e) return r; r.length > 0 && this.fireLevel2([], r) }; fireLevel1 = (t, e) => { if (0 != t.length || 0 != e.length) { var r = { request: {} }; r.request.streaming_type = this.LEVEL_1, this.session && (r.request.session = this.session), r.request.data = {}, t.length > 0 && (r.request.data.addsub = t), e.length > 0 && (r.request.data.delsub = e), this.websocketInterface.sendReq(r) } }; fireLevel2 = (t, e) => { if (0 != t.length || 0 != e.length) { var r = { request: {} }; r.request.streaming_type = this.LEVEL_2, this.session && (r.request.session = this.session), r.request.data = {}, t.length > 0 && (r.request.data.addsub = t), e.length > 0 && (r.request.data.delsub = e), this.websocketInterface.sendReq(r) } }; subscribeForAlert = () => { var t = { request: {} }; t.request.streaming_type = this.ALERTS, t.request.request_type = this.SUBSCRIBE, this.session && (t.request.session = this.session), t.request.data = {}, this.websocketInterface.sendReq(t) }; subscribeAll = () => { this.subscribeForAlert(), this.fireLevel1(this.getSymObj(this.l1SymSubscribers), []), this.fireLevel2(this.getSymObj(this.l2SymSubscribers), []) }; getSymObj = t => { let e = []; return t && Object.keys(t).forEach((t => { e.push({ symbol: t }) })), e }; onWebSocketClose = () => { !this.isStopped && this.websocketInterface.reconnect() }; onWebSocketError = t => { this.disconnectedCB && this.disconnectedCB(t) } } })(), streamingManager = n.default })();